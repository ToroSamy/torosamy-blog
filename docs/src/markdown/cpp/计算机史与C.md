---
titleTemplate: Cpp Markdown
---
# 计算机史与C

## MULTICS 和 CP/M

​MULTICS 和 CP/M 虽然没有直接的前身，但它们都站在了当时计算机技术的前沿。
**​MULTICS 更多地关注大型计算机系统，而 CP/M 则面向个人计算机市场。**

​早期批处理系统: 计算机只能顺序执行作业。
​MULTICS: 多用户、多任务分时系统，对 Unix 产生了深远影响。
​Unix: **从 MULTICS 分支出来**，强调可移植性、多用户、多任务。
​CP/M: 为 8 位微型计算机设计的操作系统，**是 DOS 的前身**。
​DOS: 基于 CP/M 开发，面向个人计算机。



## 个人计算机市场
​20世纪70年代，个人计算机开始逐渐走进人们的生活。这些早期的计算机硬件资源有限，需要一个简单高效的操作系统来管理。
​命令行界面： 当时的计算机主要通过命令行的方式进行操作，用户需要输入特定的指令来完成各种任务。



### DOS（Disk Operating System，磁盘操作系统）

#### 起源

**86-DOS：**

1980年，Seattle Computer Products公司开发了86-DOS操作系统，这是DOS的雏形。86-DOS运行在Intel 8086处理器上，并提供了一些基本的磁盘管理和文件操作功能。

**微软的介入：**

微软公司看中了86-DOS的潜力，购买了其授权，并对其进行了改进和扩展，推出了MS-DOS（Microsoft Disk Operating System）。

#### 特点：

​①单用户单任务操作系统： 只能由一个用户使用，并且一次只能运行一个程序。
​②命令行界面： 用户通过输入命令与计算机交互，没有图形界面。
​③面向磁盘操作： DOS 的主要功能是管理磁盘上的文件和程序。
​④代表： MS-DOS 是最著名的 DOS 操作系统，曾广泛应用于个人计算机。
​⑤历史地位：DOS 在**个人计算机普及**初期扮演了重要的角色，**为后来的 Windows 操作系统奠定了基础。**



## Windows 1.0 的诞生

​最早的 Windows 操作系统是 1985年 发布的 Windows 1.0。

**​在 Windows 1.0 之前，个人计算机主要使用的是命令行界面，比如 DOS**。用户需要输入复杂的命令才能操作计算机。随着计算机技术的不断发展，人们对更加直观、方便的操作界面产生了需求。

**​Windows 1.0 的出现正是为了满足这种需求。 它提供了一个图形用户界面（GUI）**，用户可以通过点击鼠标和图标来操作计算机，大大降低了使用门槛。


## 大型计算机系统

#### UNIX
起源：UNIX 起源于 1969 年，由贝尔实验室的 Ken Thompson 和 Dennis Ritchie 等人开发。它最初是为多用户、分时系统设计的操作系统。


#### linux
​linux的开发始于1991年 作者是Linus目的在于创建一个自由、开源的Unix-like操作系统**内核**，以便用户能够在个人计算机上**运行类似Unix**的环境

linux本身并不是一个完整的操作系统，而是一个 操作系统内核。内核是操作系统的心脏，负责管理系统资源、进程调度等底层任务。
开源性 是 Linux 的核心特点，这使得它成为了一个非常灵活和强大的平台。



#### Ubuntu: 基于Linux的桌面操作系统
Ubuntu 是一个基于 Linux 内核的 完整的操作系统。它在 Linux 内核的基础上，添加了桌面环境、软件包管理系统、以及大量的预装软件，形成了一个可以直接使用的操作系统。
Ubuntu 以用户友好、易于安装和使用而著称，非常适合个人用户和开发者。
Debian 是 Ubuntu 的基础，它也是一个非常流行的 Linux 发行版。

#### CentOS: 基于RHEL的企业级Linux发行版
CentOS 也是一个基于 Linux 内核的完整的操作系统，但它与 Ubuntu 有所不同。
CentOS 是 Red Hat Enterprise Linux (RHEL) 的社区版，它与 RHEL 在功能上几乎完全兼容，但完全免费。
CentOS 更注重稳定性和安全性，因此非常适合用于服务器环境。

#### 三者关系总结
Linux 是一个内核，提供操作系统的底层功能。
Ubuntu 和 CentOS 都是基于 Linux 内核构建的完整的操作系统。
Ubuntu 更面向桌面用户，而 CentOS 更面向服务器用户。


## Basic语言：
1960早年代的一种教育普及语言。 Basic语言作为一种教育语言 与后来的系统编程关系不大 。

## B语言
在1960年代 贝尔实验室参与了Multics（Multiplexed Information and Computing Service）操作系统的开发。这个项目的目标是创造一个强大、复杂的多用户操作系统。

虽然Multics在功能上非常先进 但其复杂性使得开发和维护变得困难。在Multics项目中 肯·汤普逊（Ken Thompson）和其他开发者逐渐意识到 需要一个更简单、更易于实现的操作系统。

1969年 汤普逊开始开发Unix 这个新系统的设计理念是简单性和模块化。为了支持Unix的开发而设计的 提供一种更简洁的编程语言 以便快速开发和修改系统软件，B语言诞生了。

B语言的语法和结构都经过简化 适合在当时的计算机资源有限的环境下使用。由于B语言的简单性和灵活性 它成为了Unix系统早期版本的主要编程语言。在B语言的使用过程中 开发者发现B语言的功能有限 特别是在处理数据类型和复杂结构方面。


## C语言：

#### 介绍

C语言的主要目标是为Unix系统提供一种更强大和灵活的编程语言 能够更有效地进行系统编程。
它引入了类型系统、结构体、指针等概念 增强了对系统资源的控制能力(手动管理内存)。

C语言**最初在1972年用于重写Unix操作系统**的核心部分 使得Unix能够更容易地移植到不同的计算机硬件上。**C 语言是与 UNIX 操作系统一起被开发出来的 但它不只支持UNIX。**
C语言是一门面向过程的计算机编程语言 与C++、C#、Java、Python等面向对象编程语言有所不同。

#### 特点

①直接操作硬件： C语言允许程序员直接操作硬件，包括内存、寄存器等，这对于需要精细控制硬件的嵌入式系统来说非常重要。
②执行效率高： C语言编译生成的代码执行效率高，占用系统资源少，这对于资源有限的嵌入式设备来说至关重要。
③接近汇编语言： C语言的语法相对简单，但又保留了部分汇编语言的特性，可以实现对硬件的精细控制。

#### 不是面向对象语言的原因：

​	C语言虽然有结构体 但它本质上并不是面向对象语言 这主要是因为它缺少面向对象编程的几个核心特性。

**①没有类和对象的概念：**

C语言的结构体虽然可以用来组织数据，但它不是真正的类。

类是面向对象编程的核心概念，它不仅包含数据 还包含操作这些数据的函数（方法）。C语言中没有“对象”这个概念 结构体只是一个数据集合。

**②不支持继承和多态：**

继承是面向对象编程中非常重要的特性 它允许一个类继承另一个类的属性和方法。C语言的结构体不支持继承。
​多态是指不同对象对同一消息做出不同响应的能力。C语言也没有直接支持多态的机制。

**③没有封装性：**

封装是将数据和操作数据的方法结合在一起形成一个独立的单元。C语言的结构体虽然可以封装数据，但不能很好地封装方法。


## 编程语言 和 技术栈

**编程语言：** 程序员与计算机沟通的桥梁，通过编写代码来实现特定的功能
**技术栈：** 一组协同工作的技术、工具和框架的集合，用于构建和运行应用程序

***两者的区别：***
**1、** **包含关系：** 编程语言是技术栈的一部分，但技术栈远不止编程语言
**2、** **侧重点：** 编程语言关注的是代码的语法和语义，而技术栈关注的是整个应用程序的构建和运行
**3、** **抽象层次：** 编程语言是一种相对底层的工具，而技术栈是一种更高层次的概念，它将各种技术整合在一起，提供了一个完整的解决方案
**4、** **抽象比喻：** 
**编程语言** 好比是建造房屋的砖块，是构成建筑的基本单元
**技术栈** 好比是一整套的建筑工具和材料，包括砖块、水泥、钢筋、脚手架等，以及施工图纸和施工规范

编程语言是技术栈中的一个重要的组成部分，但它们并不是同义词。技术栈是一个更广泛的概念，它涵盖了整个软件开发过程中的各种技术和工具。选择合适的技术栈对于开发高质量的应用程序至关重要。

技术栈中的很多部分确实是由编程语言开发出来的。这就像一栋大楼，编程语言是建造大楼的砖块，而技术栈就是整栋建筑。

***举个例子：***
**前端框架（如 _React，Vue_）:** 这些框架本质上就是用 _JavaScript_（一种编程语言）写成的。它们提供了一套规则和组件，帮助开发者更高效地构建用户界面
**后端框架（如 _Django,Ecpress.js_）：** 同样，这些框架也是用特定的编程语言（Python, JavaScript）写成的。它们提供了处理请求、响应、数据库交互等功能的工具。
**数据库管理系统：** 虽然数据库的底层实现可能涉及到多种编程语言，但数据库的查询语言（如*SQL*）本身就是一种专门用于操作数据的语言

***所以，编程语言和技术栈之间的关系可以总结为：***

**1、** **编程语言是基础：** 他们是构建技术栈的基石
**2、** **技术栈是集合：** 他们将多种编程语言、框架、工具等组合在一起，形成了一个完整地解决方案
**3、** **相互依存：** 编程语言用来开发技术栈，而技术栈又为编程语言提供了一个应用的场景

为什么技术栈中需要多种语言？ 
**不同层次的需求**： 不同的技术栈组件有不同的复杂度和功能。例如，底层的操作系统可能用 _C_ 语言编写，而上层的应用可能用 _Python_ 或 _JavaScript_ 编写
**历史原因**： 很多技术栈是随着时间的推移逐步演化而来的，不同的组件可能使用不同的编程语言


### 编译型语言（Compiled Languages）
**解释**: 编译型语言是指源代码在运行之前由编译器（Compiler）翻译成机器码（也称为目标代码），然后计算机的处理器直接执行这些机器码。

**特点**: 一次编译，反复执行：编译型语言的代码在运行之前必须通过编译器进行翻译，编译后的可执行文件不再需要源代码，直接可以运行。
运行速度快：由于编译后的机器码直接运行，程序的执行速度通常比解释型语言快。
调试复杂：由于编译型语言经过编译生成二进制文件，调试时需要回到源代码进行修改，并重新编译，调试相对复杂。
**常见编译型语言**: 
C、C++、Go、Rust、Fortran、Pascal

**优点**: 
**性能高**：编译后生成的二进制文件可以直接在目标机器上高效执行。
**安全性强**：源代码可以在编译后不再公开，保护了程序的源代码不被轻易查看。

**缺点**: 移植性较低：编译后的机器码与具体的硬件和操作系统相关，需要为不同平台重新编译。

### 解释型语言（Interpreted Languages）
解释型语言是指源代码不经过事先的编译，而是由解释器（Interpreter）逐行读取并直接执行代码。这意味着每次运行时，解释器都会逐行翻译和执行代码。

**特点**：
**逐行执行**：解释器逐行读取源代码并即时翻译成机器码，因此代码在每次运行时都需要解释。
**运行速度较慢**：由于解释器逐行翻译代码，相对于编译型语言，其运行速度通常较慢。
调试方便：解释型语言通常支持即时调试和修改，调试更加方便和灵活。

**常见解释型语言**：Python、JavaScript、Ruby、Perl、PHP

**优点**：
**平台独立性强**：解释型语言通常可以跨平台使用，只要有对应的解释器，程序就能在不同的平台上运行。
**灵活性高**：无需编译，修改代码后可以立即运行，非常适合快速开发和调试。

**缺点**：
**性能较差**：由于代码在每次运行时都需要逐行解释，运行速度比编译型语言慢。
**发布不便**：解释型语言需要附带源代码运行，发布时容易泄露源代码。


### 混合型语言（Hybrid Languages）
混合型语言结合了编译和解释的特点，通常先将代码编译为一种中间代码（Intermediate Code），然后由解释器或虚拟机执行这个中间代码。

**特点**：
**编译为中间代码**：源代码首先被编译为一种平台无关的中间代码（如字节码），中间代码不是机器码，无法直接在硬件上运行。
**虚拟机执行**：编译后的中间代码由虚拟机（如Java虚拟机JVM或Python虚拟机）进行解释或即时编译（JIT，Just-In-Time Compilation）为机器码。
平衡性能与跨平台性：通过中间代码的方式，混合型语言在性能和跨平台性上实现了平衡。
**常见混合型语言**：Java、C#、Python（通过字节码）、MATLAB
**优点**：
**平台独立性**：由于中间代码与具体硬件无关，程序可以在不同的系统上运行，只要有相应的虚拟机或解释器支持。
性能较好：通过JIT编译技术，虚拟机在执行时可以将中间代码编译成机器码，从而提升运行速度。
**缺点**：
**启动速度慢**：初始运行时，由于需要将代码编译为中间代码并进行解释，启动速度可能较慢。
**复杂性增加**：虚拟机和解释器的引入使得系统架构复杂，增加了程序运行时的资源占用。



|类型|执行方式|优点|缺点|代表语言|应用场景|
|--------|--------|--------|--------|--------|--------|
|编译型语言|先编译为机器码，再执行|运行速度快，性能高|编译过程复杂，移植性差|C、C++、Go、Rust|适合高性能需求的系统编程、嵌入式开发、游戏开发等领域。|
|解释型语言|逐行解释源代码并执行|开发灵活，跨平台方便|运行速度慢，源代码需要暴露|Python、JavaScript、PHP|适合快速原型开发、脚本编写、动态网页开发等场景。|
|混合型语言|先编译为中间代码，再解释或JIT执行|平衡了性能和跨平台性，具有灵活性和高效性|启动速度慢，系统架构复杂|Java、C#、Python（字节码）|适合大型企业级应用、跨平台开发，既需要性能又要求良好跨平台性的场景。|


## GNU

GNU是一个项目，是一个开发大量免费Unix软件的集合。

为什么叫GNU呢？起名就是 GNU IS NOT Unix。**其中GNU的编译器集合，又叫GCC**。

Gcc在委员会指导下，它的C编译器紧跟C标准，有各种版本以适应不同硬件平台和操作系统。如unix linux windows



### GCC、LLVM 和 Clang 是编译器领域的三大巨头，它们之间有着密切的联系。

#### GCC（GNU Compiler Collection）
​① 历史最悠久： GCC 是一个功能强大、性能优异的编译器套件，支持多种编程语言，包括 C、C++、Objective-C、Fortran 等。
​② 开源： GCC 是一个开源项目，经过多年的发展，拥有庞大的用户社区和丰富的生态系统。
复杂性高： 由于历史悠久，GCC 的代码库非常庞大且复杂，这使得它的维护和扩展变得困难。

#### LLVM（Low Level Virtual Machine）
​① 模块化设计： LLVM 采用模块化的设计，将编译过程分为前端、优化器和后端三个阶段。这种设计使得 LLVM 具有高度的灵活性，可以支持多种编程语言和硬件平台。
​② 中间表示（IR）： LLVM 引入了中间表示（IR），这是一种类似于汇编语言的低级语言，但具有更强的表达能力。IR 使得 LLVM 可以进行更高级的优化。
​③ 可扩展性强： LLVM 的架构非常灵活，可以方便地添加新的前端和后端，支持新的编程语言和硬件平台。

#### Clang
① LLVM 前端： Clang 是 LLVM 的一个前端，主要用于编译 C、C++ 和 Objective-C 语言。
② 性能优异： Clang 的编译速度比 GCC 更快，错误提示也更加友好。
③ 模块化设计： Clang 继承了 LLVM 的模块化设计，具有高度的灵活性。

#### 三者之间的关系

① Clang + LLVM = GCC 的替代品： Clang 和 LLVM 的组合可以作为一个完整的编译器，在很多方面都优于传统的 GCC。
② LLVM 是一个基础设施： LLVM 提供了一个强大的编译器基础设施，Clang 是基于 LLVM 的一个前端。
④ GCC 兼容 LLVM： GCC 也可以使用 LLVM 作为后端，这使得 GCC 可以受益于 LLVM 的优化和扩展能力。

#### 总结

GCC 是一款成熟稳定的编译器，但其复杂性限制了它的发展。
LLVM 提供了一个灵活的编译器基础设施，具有良好的可扩展性。
Clang 是一个基于 LLVM 的高性能编译器前端，在编译速度和错误提示方面表现出色。



#### 在选择编译器时，可以根据以下因素进行考虑：

1.项目需求： 如果需要支持多种编程语言或进行复杂的优化，LLVM 是一个不错的选择。
2.编译速度： 如果对编译速度有较高要求，Clang 是一个很好的选择。
3.生态系统： GCC 拥有庞大的生态系统，而 LLVM 的生态系统也在不断发展。

**总的来说，LLVM 和 Clang 的出现为编译器领域带来了新的活力，它们正在逐渐取代 GCC 的地位。**







## MinGW（全称: Minimalist GNU for Windows）


**C编译器不是windows的标准软件包的一部分，你需要从网上下载(如MinGW)，以便于在pc上使用命令来操作GCC编译器**

作用: 将 GCC 编译器移植到了 Windows 平台上，使得我们在 Windows 系统上可以使用 GCC 来编译 C/C++ 代码。
特点:
① 提供了在 Windows 上使用 GCC 的接口。
② 包含了 Win32 API，使得编译出来的程序可以在 Windows 环境下运行。

## CMake

作用: 一个跨平台的构建工具，用于生成特定平台的构建文件（如 Makefile、Visual Studio 项目文件等）。
特点:
① 编写 CMakeLists.txt 文件来描述项目结构和编译规则。
② 可以根据不同的平台和编译器生成相应的构建文件。
③ 简化了项目构建过程，提高了可移植性。

## GCC（全称: GNU Compiler Collection）

作用: 一个功能强大的编译器套件，用于将 C、C++ 等高级语言编译成机器码。
特点:
① 开源免费，支持多种编程语言。
② 编译优化能力强，生成高效的机器码。

## 三者之间的关系

CMake 生成构建文件，GCC 执行编译: CMake 通过解析 CMakeLists.txt 文件，生成适合当前平台的构建文件（如 Makefile）。然后，构建工具（如 make）会根据生成的构建文件调用 GCC 编译器来编译源代码。
Mingw 提供 GCC 在 Windows 上的运行环境: Mingw 将 GCC 移植到了 Windows 平台上，使得我们可以使用 CMake 生成针对 Mingw 的构建文件，然后使用 Mingw 提供的 GCC 编译器来编译我们的项目。

## 流程
1.Cmake读取cmakeList.txt文件，确定结构、源码文件和依赖项目
2.Cmake根据系统环境和选定的编译器(minGW) 生成对应的构建文件(MakeFile)
3.minGW通过make命令调用gcc或g++



## g++
**g++介绍**
1.C++ 编译器的代名词： 由于 g++ 在 C++ 社区中非常流行，以至于很多人将 g++ 等同于 C++ 编译器。
2.简单易用： g++ 的命令行选项相对简单，易于上手，所以被广泛使用。
3.开源免费： 作为 GCC 的一部分，g++ 也是开源免费的，这使得它成为了很多开源项目的首选编译器。

**g++ 与 GCC 的关系**
1.g++ 是 GCC 的一部分： g++ 是 GCC 中专门用于编译 C++ 代码的编译器。
2.功能重叠： 实际上，gcc 和 g++ 可以用来编译 C++ 代码。之所以有 g++，主要是为了方便用户记忆和使用。



## 编译
**编译就是将源代码翻译成 机器能看懂的机器代码。编译永远是以单个源文件为单位的**

#### 过程
.c文件经过预处理生成对应的.i文件，预处理会把.c文件和头文件展开到.i文件当中。

接着.i预处理文件经过编译 生成了汇编文件.s 汇编文件中就是汇编代码。

之后汇编文件经过汇编，生成了对象文件，也就是目标文件，以elf格式保存起来。



通过编译之后，就会将源文件编译成目标文件。

ELF linux下所有的可执行格式。

相应的windows下 PE 虽然互不兼容，但结构相似，都是对二进制代码的一种封装。
可以在文件头部找到可执行文件的头部信息，比如操作系统 机器类型。
后面是区块section，里面是机器代码和程序的数据。



但是.o并不可以执行，编译器并不知道声明的add和 printf。

链接就是将编译之后的所有目标文件，连同用到一些静态库 运行时库组合拼装成一个独立的可执行文件。

#### 翻译单元 

​可以理解为你认为的多个文件在编译器中可能以一个文件出现。
​例如，通常在源代码中包含一个或多个头文件，头文件会依次包含其他头文件，所以会包含多个单独的物理文件。但是 ，c预处理实际上使用包含的头文件内容替换#include指令。所以编译器源代码文件和所有的头文件都看成一个包含信息的单独文件，这个文件被称为翻译单元。

​描述一个具有文件作用域的变量时，他的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将有多个翻译单元组成。每个翻译单元均对应一个源代码文件和她所包含的文件。


**ISO**： ISO（_International Organization for Standardization_，国际标准化组织）

**ANSI** ： ANSI（_American National Standards Institute_，美国国家标准协会）
ANSI C也就是美国国家标准协会发布的C语言的标准，因为这个东西本来就是人家创建的，所以他说的就是标准，就是这么简单。

**C标准**
下面说的各个C语言的发布版本都是C语言的标准，只是版本的更迭

* **C89** 
1983年，美国国家标准协会（_ANSI_）成立了一个委员会 _X3J11_ ，以建立C的标准规范。

* **C90**
1990年，国际标准化组织（_ISO_）采用了ANSI C标准（格式有所更改），称为 _ISO / IEC 9899：1990_ ，也称为 _C90_ 。所以 _C89_ 和 _C90_ 几乎上是同一个标准，本来 _C89_ 是 _ANSI_ 在83创建的，然后在90年 _ISO_ 采用了这套标准。

* **C99**
进一步修订 _C_ 标准，于1999年发布 _ISO / IEC 9899：1999_ ，通常被称为 _C99_ 。引入了一些新的特性。比如内联函数，几种新的数据类型等等。

* **C11**
2011年12月8日正式发布， _C11_ 标准为 _C_ 和库添加了许多新功能，包括类型通用宏，匿名结构，改进的 _Unicode_ 支持，原子操作，多线程和边界检查功能。它还使现有 _C99_ 库的某些部分可选，并提高了与 _C ++_ 的兼容性。

C标准不仅描述c语言，还描述如何执行c域处理器，c标准库有哪些函数以及详述这些函数的工作原理。C域处理器在程序执行之前查看程序，故称之为预处理器。根据程序中的预处理器操作，预处理器把符号缩写替换成其表示的内容。预处理器可以包含程序所需的其他文件。基本上他的工作是把一些文本转换成另外一些文本。


## 为什么要学习现代cpp

在没有 _GC_ 的世界里，程序员必须自己手动进行内存管理，必须清楚地确保必要的内存空间，释放不要的内存空间。

程序员在手动进行内存管理时，申请内存尚不存在什么问题，但在释放不要的内存空间时，就必须一个不漏地释放。这非常地麻烦。容易发生下面三种问题：内存泄露，悬垂指针，错误释放引发BUG。

**_C++_ 本身没有像 _Java_ 或 _C#_ 那样的内置垃圾回收（GC）机制**，但它提供了多种工具和方法来管理内存，避免**内存泄露和悬空指针**问题。以下是一些常见的内存管理方式：

**手动管理内存**
 _C++_ 提供了 _new_ 和 _delete_ 操作符用于动态内存分配和内存释放。程序员必须显式调用 _delete_ 来释放分配的内存，否则会导致内存泄漏。
```
int* ptr = new int(10)
delete ptr;//释放内存 
```
**智能指针**
 _C++11_ 引入了智能指针，它们通过自动管理内存的生命周期，减少了手动释放内存的负担。
 std::unique_ptr: 拥有为一所有权，当智能指针超出作用域时，自动释放内存。
 ```cpp
std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
 ```
std::shared_Ptr:实现共享所有权，只有当最后一个指向对象的  _shared_ptr_ 被销毁时，内存才会被释放。
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
std::shared_ptr<int> ptr2 = ptr1;  // 共享同一内存
```
std::weak_ptr:用于避免循环引用，不要直接访问资源，需要先提升到 _shared_ptr_ 才能使用

```cpp
std::weak_ptr<int> weakPtr = ptr1;  //不增加引用计数
```
**RAII（资源获取即初始化）**
_C++_ 的 _RAII_ 对象（_Resource Acquisition Is Initialization_）是一种通过对象的生命周期来管理资源的方式，尤其适用于文件句柄、锁和动态内存等资源。
当对象超出作用域时，它的析构函数会自动调用，用来释放资源。
```cpp
class MyClass{
public:
    MyClass(){
        //资源初始化
    }
    ~MyClass(){
        //资源释放
    }
};
```
**第三方垃圾回收库**
虽然  _C++_ 本身没有内置的垃圾回收，但可以通过第三方库来实现，例如：
_Beohm-Demers-Weiser_ 垃圾回收器：一个广泛使用的 _C/C++_垃圾回收库，它可以实现自动内存管理。

**总结：**
_C++_ 更强调程序员对内存的显式管理，而不像 _Java_ 等语言那样完全依赖垃圾回收机制。然而，借助智能指针和 _RAII_ 等现代 _C++_ 特性，程序员可以在很多情况下避免手动管理内存，同时有效避免内存泄漏等问题。

## 为什么要学习STL？

_C++_ 中的 _STL_ (_Stanard Template Library_)容器，**在很大程度上可以帮助开发者避免显式管理内存**。_STL_ 容器如 _std::vector, std::list, std::map_ 等都自动管理内存分配和释放，因此**可以有效的避免内存泄漏和悬空指针**等问题。以下是 _STL_ 帮助避免显示内存管理的一些关键点:
**自动内存管理**
当你使用 _STL_ 容器时，容器会自动管理内部元素的内存分配和释放。例如，_std::vector_ 在需要时自动扩展其容器，并在销毁时释放所有分配的内存。
```cpp
std::vector<int> vec = {1, 2, 3, 4}; //自动分配内存
vec.push_back(5); // 如果容量不够，自动重新分配更多的内存
//当 vec 超出作用域时。内存会自动释放
```
**对象的生命周期管理**
_STL_ 容器中的元素以值的方式储存，这意味着当你将一个对象插入到容器中时，容器会拷贝或者是移动该对象。当容器被销毁时，所有对象的内存都会自动释放。
例如，对于 _std::list_ 或 _std::map_ 这样的容器，你无需担心节点或键值对的手动内存释放，容器析构时会自动清理所有的元素。
```cpp
std::list<std::string> strList = {"hello","world"};
// 不需要手动管理内存，strLsit 离开作用域是自动释放
```
**防止内存泄漏**
_STL_ 容器通常能够防止内存泄漏。例如，在 _std::vector_ 中，当其容量不足时，会自动分配内存空间，复制旧数据并释放旧的内存。这就避免了手动管理内存带来的复杂性和错误。
**RAII(_资源获取即初始化_)**
_STL_ 容器遵循 _RAII_ 原则：当容器超出作用域时，它的析构函数就会调用，自动释放所有管理的资源（即使在异常发生时也能确保内存被释放）。
例如：
```cpp
void func(){
    std::vector<int> numbers = {1, 2, 3, 4};
    //函数结束时，numbers 自动释放，无需调用 delete
}
```
**处理动态分配对象的容器**
虽然 _STL_ 容器可以处理内置类型和自动管理的对象类型，但如果你在容器中存储动态分配的指针，需要显式管理这些指针的生命周期。
不过，可以使用 智能指针 （如： _std::shared_ptr_ 或 _std::unique_）与容器结合，避免手动释放指针对象的内存。
```cpp
std::vector<std::shared_ptr<int>> vec;
vec.push_back(std::make_shared<int>(10));  //使用智能指针存储动态分配的对象
//无需手动释放，智能指针会自动管理内存
```
**异常安全性**
_STL_ 容器在处理异常时也能够安全的释放资源。即使程序在插入、删除或重新分配时抛出异常，_STL_ 容器也能够确保已经分配的内存被正确释放，不会发生内存泄漏。