---
titleTemplate: Cpp Markdown
---
# 基本特性
从硬件方面来看 被储存的每个值都占用一定的物理内存 c语言把这样的一块内存成为对象 面向对象编程中的对象指的是类对象

C种的对象可以储存一个或多个值 一个对象可能并未储存实际的值 但是它在储存适当的值时一定具有相应的大小




## 内存相关

#### 内存
程序把可用的内存分为3部分
1. 具有外部链接 内部链接 和 无连接的静态变量使用
静态存储类别所用的内存数量在编译时确定 只要程序还在运行 就可以访问储存在该部分的数据。
该类型的变量在程序开始执行时被创建,在程序结束时被销毁。

2. 自动变量使用
自动储存类型在进入块时存在 离开快时消失 因此随着程序调用函数 和函数结束 自动变量所用的内存数量也相应地增加减少
这部分的内存通常作为栈来处理 这意味着新创建的变量按顺序加入内存 以相反的顺序销毁

3. 动态内存分配
动态分配的内存在调用malloc或相关函数时存在 在调用free释放 这部分内存有程序员管理
所以内存块可以在一个函数中创建 另一个函数中销毁
通常使用动态内存会比使用栈内内存慢

#### 内存泄露
**malloc和calloc**
malloc和calloc都可和变长数组int arr[n] 在**运行时**才知道数组大小
malloc和calloc都返回一个指针 用于free来释放
```cpp
void fun() {
    double *temp = (double*) malloc(n*sizeof(double));
  //long *newmem = (long *) calloc(100,sizeof(long));

    //如果不free 就会内存泄漏 
    free(temp);
}
```


**new**
new可以直接分配单个变量的内存，也可以分配数组。

在分配单个对象的内存时:
当对象是普通变量时，可以分配对应的内存
```cpp
    //不初始化 只能在汇编层次上判断
    // int* pi = new int();
    int* pi = new int(100);
    std::cout<<*pi<<std::endl;
    //如果不delete 就会内存泄漏 
    delete pi;
```

当对象是类对象时，会调用构造函数，如果没有对应的构造函数，就会报错。
```cpp
    //不初始化 默认构造函数 为空字符串
    // std::string* pString = new std::string("");
    std::string* pString = new std::string("hello world");
    std::cout<<*pString<<std::endl;
    delete pString;
```

在分配数组对象内存时：
对于普通变量：可以使用“（）”将所有对象全部初始化为0。
```cpp
    //不初始化 只能在汇编的角度判断
    // int* pArr = new int[100];
    int* pArr = new int[100]();
    std::cout<<pArr[20]<<std::endl;
    delete[] pArr;
```


对于类对象，有没有“（）”都一样，均使用默认构造函数，如果没有默认构造函数就会报错。
```cpp
    std::string* pString = new std::string[100]();
    std::cout<<pString[20] <<std::endl;
    delete[] pString;
```
```cpp
//该程序报错
class Test{
public:
    Test(int i): i(i) {}
private:
    int i;
}

int main() {
    //语句报错
    //Test* pTest = new Test[100]();
    //Test* pTest = new Test[100];

    delete[] pTest;
    return 0;
}

```

内存泄露会导致堆内存的逐渐被占用，最终内存用完程序崩溃。常见的情况就是项目测试没问题，上线几天就炸了。然后就会非常麻烦，排查困难，损失很大。
**内存泄露是最严重的错误之一，程序不怕报错，就怕一开始运行的好好的，突然就出现了莫名其妙的错误。**
这句话也引出了后面的两个部分。
## 库目录
.h文件通常包含2种库 **静态库(.lib)**和**动态库(.dll)**
在程序**编译**时用到**静态**库(.lib) 在程序**运行**时用到**动态链接**库(.dll)

## 命名空间
C++经常需要多个团队合作来完成大型项目。多个团队就常常出现起名重复的问题，C++就提供了命名空间来解决这个问题。
比如团队A和团队B都需要定义一个叫做Test的类。那么可以这么做
```cpp
//这是ATest.h文件
#pragma once
namespace A{
    void test();
}
```
```cpp
//这是ATest.cpp文件
#include "ATest.h"
#include <iostream>
namespace A{
    void test() {
        std::cout<< "A::()"<<std::endl;
    }
}
```
```cpp
//这是BTest.h文件
#pragma once
namespace B{
    void test();
}
```
```cpp
//这是BTest.cpp文件
#include "BTest.h"
#include <iostream>
namespace B{
    void test() {
        std::cout<< "B::()"<<std::endl;
    }
}
```

```cpp
//这是main.cpp
#include <iostream>
#include "ATest.h"
#include "BTest.h"

int main() {
    A::test();
    B::test();
    return 0;
}
```
顺便提两点：
	命名空间的实现原理，C++最后都要转化为C来执行程序。在namespace A中定义的Test类，其实全名是A::Test。
C++所有特有的库（指c没有的库）,都使用了std的命名空间。比如最常用的iostream。
**cout是一个对象 定义在std的命名空间当中**

#### using关键字
using关键字设计的目的之一就是为了简化命名空间的。using关键字在命名空间方面主要有两种用法。
1. using 命名空间::变量名
这样以后使用此变量时只要使用变量名就可以了。
2. using namspce 命名空间
这样，每一个变量都会在该命名空间中寻找。
**所以，头文件中一定不能使用using关键字。会导致命名空间的污染。**

## 输入输出
#### C语言输入输出(知识点补充)
1. %5.2f 是宽度为5 显示小数点后两位
2. printf返回打印的字符串长度
```c
int a = 1;
int b = 2;
float c = 1.1
printf("weight = %*.*f\n",a,b,c);
//printf("weight = %1.2f\n",c);
```
```c
printf("%s,%p,%c","we","are",*"space")
// %s打印"We"
// %p打印are的首个字符的地址
// *"space"表示该字符串中所指向地址上储存的值
```
3. scanf返回成功读取的项数 需要输入int 却输入char 则返回0
```cpp
scanf("%d, %d",&n,&m);
//输入的时候 必须在2个数之间加","
//scanf会忽略""里面的空格
```
因为scanf忽略空白字符,无法读取整书名。fgets()更适合。
4. strncut(原来的 apped indexlin)
5. strncpy和上述一样



#### C++的标准输入输出简介
输入输出简单来说就是数据在输入设备，内存，硬盘，输出设备之间移动的过程。
c语言设定了很多不相关的函数还实现这些过程。
比如printf就是让数据从内存到显示屏（显示屏就是输出设备）。scanf就是让数据从键盘（键盘是输入设备）到内存。此外还有从内存到磁盘的文件操作函数。

c语言的函数虽然简单方便，但彼此之间没有关联。C++有了继承功能，可以让子类与父类之间有关联性，极大的提高各种输入输出功能之间的耦合性。
于是C++用继承功能重写了输入输出功能，这就是io库，io库引入了“流”的概念，数据从一个地方到另一个地方，原本地方的数据就没了，叫做流很贴切。

io库是一个很大的部分，但现阶段我们只要会使用输入输出流，cout和cin就可以了。
cout可以让数据从内存流到输出设备，cin可以让数据从输入设备流到内存。

**等到Part7，io库会详细讲解。**

## nullptr和NULL

**类型安全:**
nullptr 是C++11引入的关键字，它是一个指针类型，明确表示空指针。
NULL 是一个宏定义，通常被定义为整数0或者(void*)0。在C++中，NULL 可能会被解释为整数0，这可能导致一些类型安全问题。
**代码可读性:**

使用 ``nullptr`` 可以更清晰地表达你的意图，表明你正在使用一个空指针。
使用 ``NULL`` 时，可能会让人误以为是一个整数0，降低代码的可读性。
**函数重载:**
在函数重载时，``nullptr`` 可以更好地匹配指针类型的参数，避免歧义。
``NULL`` 可能会被解释为整数0，导致重载决策错误。

**总结:**
- 在C++中，推荐使用 ``nullptr`` 来表示空指针，因为它更安全、更具可读性，并且可以避免函数重载时的歧义。
- 尽量避免使用 ``NULL``，特别是在C++代码中。

## const关键字介绍
const是让编译期将变量视为常量，用const修饰的变量和真正的常量有本质的区别。


1. 真正的常量存储在常量区或代码区，比如“abcdefg”这个字符串就存储在常量区，而“3”，“100”这些数字就存储在代码区中，这些都是真正的常量，无法用任何方式修改。

2. const修饰的变量仍然存储在堆区或栈区中，从内存分布的角度讲，和普通变量没有区别。const修饰的变量并非不可更改的，C++本身就提供了mutable关键字（这个关键字在Part3就会讲的）用来修改const修饰的变量

从汇编的角度讲，const修饰的变量也是可以修改的。
```cpp
const char* pc = "xxxxxx"
//const只能保证被pc指向的字符串不被修改 但是不能保证pc不能指向别的字符串
```
3. const 放在* 左侧任意位置 限定了指针指向的数据不能改变 右侧限定了指针不能改变
## auto关键字的使用
1. auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号。
2. auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。
3. auto关键字在推断类型时，如果没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。可能有些不好理解，看看代码就好说了。3和4的主要作用对象就是指针。
```cpp
int main() {
    int i = 100;

    const int* const pi = &i;

    auto pi2 = pi;
    //auto 就是 int const *   (const int *)
}
```
**没有引用修饰 就是值传递 auto获取值的类型**
4. auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留
**因为在传递值时，修改这个值并不会对原有的值造成影响。而传递引用时，修改这个值会直接对原有的值造成影响。**
```cpp
int main() {
    int i = 100;

    const int* const pi = &i;

    auto& pi2 = pi;
    //全部保留
}
```
5. 当然，我们可以在前面加上const，这样永远都有const的含义。
```cpp
int i = 100;
const auto i2 = i;
```
6. auto不会影响编译速度，甚至会加快编译速度。因为编译器在处理XX a = b时，当XX是传统类型时，编译期需要检查b的类型是否可以转化为XX。当XX为auto时，编译期可以按照b的类型直接给定变量a的类型，所以效率相差不大，甚至反而还有提升。
7. （*）最重要的一点，就是auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先。
8. （*）auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题。
9. 自动变量：auto是储存类别说明符 cpp中的auto和c的auto完全不同 在编写c/cpp兼容程序 **最好不要用auto作为储存类别说明符(auto int lpox)** 但是可以用 自动类型推断(auto a = xxx)

**注意：auto的用法这里大致了解就可以了，Part10会有一节详细的讲auto的类型推断的，这节课是没有涉及右值引用的，那里会将这一部分。而且现在没有讲模板，难以讲出auto关键字的主要用法。**

## 静态变量，指针和引用


#### 静态变量相关
变量的存储位置有三种，分别是静态变量区，栈区，堆区。

**作用域**
1. 块作用域(花括号里面的)
2. 函数作用域(仅用于goto)
3. 函数原型作用域(用于函数原型中的参数名) 
4. 文件作用域(文件作用域的变量是使用static关键字定义的全局变量，或者直接在文件的顶部声明的全局变量。这些变量只能在定义它们的源文件中访问，无法被其他文件中的代码引用。这种作用域有助于避免命名冲突，并使变量的使用限制在特定的文件内)


**链接**
1. 无链接
具有块作用域 函数作用域 或者函数原型作用域的 都是无链接 这意味着他们属于他们的块 函数 原型私有
2. 外部链接 内部链接
具有文件作用域的才区分内部外部 外部可以被多个文件程序使用 内部只能在一个*翻译单元*中使用




**存储器**
可以用储存期来描述对象在内存当中保留了多长时间
1. 静态存储期
如果对象具有静态存储器 那么在程序执行期间一直存在
文件作用域变量具有静态存储器 
**注意 对于文件作用域的变量 static表明了其链接属性 而非存储期**
被static声明的文件作用域的变量具有内部链接 但无论内部外部 文件作用域都具有静态存储期
2. 线程存储期
用于并发程序设计 程序执行可被分为多个线程 具有线程存储期的对象 从被声明到线程结束一直存在
以关键字_Thread_local 声明一个对象时 每个线程都获得该变量的私有备份
3. 自动储存期
块作用域的变量通常都具有自动存储器 自动分配 自动释放
4. 动态分配存储期 p377表格


**静态变量**
1. 静态变量可以创建"静态存储器、块作用域、局部"的变量。这些变量和自动变量具有相同的作用域。
但是程序离开他们所在的函数后 静态变量不会消失 也就是说静态变量是"块作用域 无连接 静态存储期"

2. 外部链接的静态变量 具有文件作用域 外部链接 和静态存储期。该类别有时被称为外部储存类别 属于该类别的变量成为外部变量 把变量的定义型声明 放在所有函数的外面便创建了外部变量
当然为了指出该函数使用了外部变量 可以用extern再次声明
```c
int Errupt; //外部定义的变量
double up[100]; //外部定义的数组
extern char Coal; //如果cola被定义在另一个文件 则必须这么声明

int main() {
  extern int Errupt;//可选的声明
  extern double up[100];//可选的声明
}
```
3. 静态变量区在编译时就已经确定地址，存储全局变量与静态变量。
```cpp
#include <iostream>
//g_i和test当中的callCount在编译时就已经确定
//代码运行时 会直接忽略static unsigned callCount = 0;这一句
unsigned g_i = 0;
unsigned test() {
    static unsigned callCount = 0;
    return ++callCount;
}

int main() {
    test();
    test();
    test();
    unsigned testFuncCallCount = test();
    std::cout << testFuncCallCount << std::endl;
    return 0;
}
```

4. 声明全局变量很危险 但是可以用const 修饰保证数据安全
5. 好处是可以偷懒
坏处是 数据是重复的 相当于给每个文件提供了一个数据副本 对于前面的例子来说这不是什么问题 对于const修饰的庞大数组 就不能视而不见
```c
//文件A
static const double PI = 3.14
```
```c
文件B
#include "A.h"
```
```c
文件C
#include "A.h"
```


#### 指针相关

**指针**
在计算机操作系统中 地址按字节储存 不要解引用未初始化的
指针都是存储在栈上或堆上，不管在栈上还是堆上，都一定有一个地址。
声明 指针变量 必须指定 指针所指向 变量的数据类型 **因为不同的变量类型占用不同的存储空间**
**本质上说，指针和普通变量没有区别。**

在32位系统中，int变量和指针都是32位。指针必须和“&”，“*”这两个符号一起使用才有意义。
&a代表的a这个变量的地址，a代表的a对应地址存储的值，*a代表对应地址存储的值作为地址对应的值，这句话可能不好理解。
```cpp
int main() {
    int i = 20;
}
//i表示所储存的值
//&i表示i的地址
//*i 表示地址为20的对象 所储存的值
```



所以指针才可以灵活的操作内存，**但这也带来了严重的副作用，比如指针加加减减就可以操作内存**，所以引用被发明了，引用就是作用阉割的指针（可以视为“类型*const”，所以引用必须上来就赋初值，不能设置为空），编译器不将其视作对象，操作引用相当于操作引用指向的对象。**也就从根本是杜绝了引用篡改内存的能力。**

**新手如果不懂内存，就直接将引用视为指向对象的别名就可以了。**

**要真正理解指针，引用是需要学习c语言对应汇编的，只要懂了汇编，一目了然。不懂汇编就只能这样理解了。**



**数组**
数组名是该数组首元素的地址 作为实际参数的数组名要求形式参数是一个与之匹配的指针
只有在这种情况下 c才会把int ar[]和int* ar解释成一样 也就是说 ar是指向int的指针
1. 字符数组所有未被使用的元素都被自动初始化为'\0'
```c
//m1和m2不一样 因为m2 最后缺少空字符 \0
const char m1[40] = "helloworld";
const char m2[40] = "'H','e','l'....";

//让编译器确定初始化字符数组的大小很合理 
//如果创建一个稍后再确定的数组就必须在声明时指定大小
const char m3[] = "if you";
```
2. 通常字符串都作为可执行文件的一部分 储存在数据段中
当把程序载入内存时 也载入了程序中的字符串(储存在静态储存区)。程序运行时 才会为该数组分配内存 此时将字符串拷贝到数组中。此时字符串副本有2个 一个是静态内存区 一个是array中的。
3. *p和array[]定义数组
- *p允许++p p++这样的操作。array[]不允许
- *p通常只能用于变量前,不能用于常量。
- array[]是地址常量
- *p 该变量是最初指向该字符串的首字符
- 如果打算修改字符串 就不要用指针指向字符串字面量

## 左值，右值，左值引用，右值引用
#### 左值和右值
左值右值从C++11开始就是一个很重要的概念了，但想要真正理解左值，右值不是一件容易的事。
尤其新人要彻底理解左值右值就更加困难了，所以我推荐新手将这些概念死死记住，带着疑惑学习下面的课程，积累的多了，自然就明白了。后面左值，右值的概念会被反复提及。

C++任何一个对象要么是左值，要么是右值。
比如int i = 10，i和10都是对象
**左值**：拥有地址属性的对象就叫左值，左值来源于c语言的说法，能放在“=”左面的就是左值，注意，左值也可以放在“=”右面。

**右值**：不是左值的对象就是右值。或者说无法操作地址的对象就叫做右值。一般来说，判断一个对象是否为右值，就看它是不是左值，有没有地址属性，不是左值，那就是右值。

比如临时对象，就都是右值，临时对象的地址属性无法使用。
```cpp
int main() {
    int i = 10;
    int i2 = i + 1;
    //(i + 1) = 200;  (i + 1)就是一个临时对象
}
```
注意：左值也可以放在“=”右面，但右值绝对不可以放在等号左面
接下来就是大量举例了，说明那些是左值，哪些是右值。
```cpp
int main() {
    int i = 200;
    ++i = 200; //先++ 然后返回i的对象
    //i++ = 200; 
}
```


#### 引用的分类 

(1)	普通左值引用：就是一个对象的别名，只能绑定左值，无法绑定常量对象。
```cpp
int main() {
    // const int i = 100;
    // int& refI = i;
    // refI = 200;
    // 如果使用了引用 const则形同虚设 所以不允许这么写
    int i = 100;
    //引用相当于别名
    int& refI = i;
}
```
(2)	const左值引用：可以对常量起别名，可以绑定左值和右值。
```cpp
int main() {
    const int i = 100;
    const int& refI1 = i;
    const int& refI2 = 200;
}
```
(3)	**右值引用**（暂时不要去管右值引用有什么用，只要记住语法就可以了，实际用途下一课就会讲到）：只能绑定右值的引用。
```cpp
int main() {
    int i = 100;
    int&& rightRefI1 = i++;
    int&& rightRefI2 = (i + 1);
    //int&& rightRefI3 = i;
}
```
(4)	万能引用：这节课不讲，等到part10涉及模板时再讲，这是一个很重要，但需要模板等基础的概念。

## move函数，临时对象
#### move函数：
(1)	右值看重对象的值而不考虑地址，move函数可以对一个左值使用，使操作系统不再在意其地址属性，将其完全视作一个右值。
```cpp
int main() {
    int i = 10;
    int&& rightRefI = std::move(i);
    //std::move(i)整体右值
    //i仍然是左值 可以赋值 但不要这样做 
    //i = 20;
}
```
(2)	**move函数让操作的对象失去了地址属性，所以我们有义务保证以后不再使用该变量的地址属性，简单来说就是不再使用该变量，因为左值对象的地址是其使用时无法绕过的属性。**
**move函数的具体意义现阶段无需在意，Part3讲移动语义时会体现move函数意义的。**

#### 临时对象：
**右值都是不体现地址的对象。那么，还有什么能比临时对象更加没有地址属性呢？右值引用主要负责处理的就是临时对象。**
程序执行时生成的中间对象就是临时对象，注意，所有的临时对象都是右值对象，因为临时对象产生后很快就可能被销毁，使用的是它的值属性。

```cpp
int getI() {
    return 10;
}

int main() {
    int i = 10;
    //getI()返回的值就是临时对象
    int&& refI = getI();
}

```
#### 总结：
右值和右值引用这里只介绍语法，等到Part3的第11课，会学习移动构造，右值引用会真正体现出提高程序性效率的功能。




## 拓展数据类型
|关键字|描述|
|--------|--------|
|_Complex|复数类型|
|_Imaginary|纯虚数类型|
|_Bool|布尔类型 但实际是0和1|
||stdbool.h 是C标准函数库常用的头文件|

|宏名称|展开|
|--------|--------|
|bool|_Bool|
|true|整数常量1|
|false|整数常量0|
|__bool_true_false_are_defined|整数常量1|


## sizeof
计算机最小储存单位是位bit。一个字节8位，例如int类型占4个字节。
```c
char name[40]; //实际只能储存39个字符 留一个给/0 空字符
```
sizeof 计算一个对象或类型所占的内存字节数。而strlen是计算字符串长度。例如name是40个char类型的

sizeof 返回的size_t类型是一个无符号整型，但size_t不是一个新类型，size_t会根据不同系统替换。
```c
//typedef unsigned (int||long)
```
## 浮点数存储：

#### 表示法
浮点数的存储通常遵循IEEE 754标准，这种表示法分为三部分：符号位、指数位和尾数（或称有效位）。

**符号位**: 占1位，表示浮点数的正负。0表示正数，1表示负数。
**指数位**: 在单精度浮点数中占8位，在双精度浮点数中占11位。指数采用偏移量（bias）表示法。在单精度中，偏移量是127；在双精度中，偏移量是1023。实际的指数值通过将存储的值减去偏移量获得。
**尾数（有效位）**: 在单精度中占23位，在双精度中占52位。浮点数采用规范化形式表示，意味着尾数前面有一个隐含的1（对正常数有效），实际存储的尾数是这个1后面的部分。比如，二进制数1.101在存储时只记录.101，并隐含前面的1。


#### 示例
以单精度浮点数-6.75为例
- 符号位：1（负数）
- 转换成二进制：-6.75转为二进制为-110.11，规范化为-1.1011 × 2^2。
- 指数计算：2 + 127 = 129，129的二进制是10000001。
- 尾数：去掉隐含的1，记录为10110000000000000000000。

最终，-6.75的存储形式为：
- 符号位：1
- 指数位：10000001
- 尾数：10110000000000000000000

**总结: 浮点数的存储通过将数值分为符号、指数和尾数，能够有效表示范围广泛的实数。然而，这种表示法也可能引入精度损失和舍入误差，特别是在进行浮点运算时，因此在编程时需特别注意。**


## typedef

#### 特性
||#define|typedef|
|--------|--------|--------|
|创建的符号受限范围|类型和值|类型|
|解释|预处理器|编译器|

|typedef定义在|函数中|函数外|
|--------|--------|--------|
|typedef具有|局部作用域|文件作用域|

#### 语法
```c
typedef unsigned char BYTE;
BYTE x, y[10], *z;
```
#### 应用场景
- 方便tine_t、size_t等类型 在不同系统代表不同类型
- 简化书写的类型，例如
```c
//把FRPTC 声明为一个函数类型 该函数返回一个指针
//该指针指向内含5个char类型元素的数组
typedef char (*FRPTC()) [5];
```


||||
|--------|--------|--------|
|int *risks[10]|声明一个内含10个元素的指针|每个元素都指向int|
|int (*risks)[10]|声明一个指向数组的指针|该数组内含10个int类型|
|int *oof[3][4]|3*4二维数组|每个元素都是指向int的指针|
|int (*oof)[3][4]|声明一个指向3*4二维数组的指针|每个元素int类型|


## 高速缓存
在C语言中，高速缓存优化是编译器提高性能的一种方式。例如：
```c
int val1 = x;
//一些不使用x的代码
int val2 = x;
```
智能的编译器会注意到x的值在两次读取之间未改变，因此可能将x的值临时存储在寄存器中，以减少对主内存的访问时间。这种过程被称为缓存。

然而，如果在这两条语句之间，有其他代码修改了x的值，编译器就无法安全地进行这样的优化。因此，如果没有volatile关键字，编译器无法确定x是否会被外部因素改变，出于安全考虑，它会避免优化。

当声明中使用了volatile，编译器将假定变量的值在使用过程中可能变化，这时不会缓存值。通常，const与volatile可以同时使用，const用于表示变量不可被程序修改，但可能被外部代理修改，而volatile则表示变量可能会被外部因素改变。

这两个限定符的顺序不影响其功能，但必须在声明中同时使用。