---
titleTemplate: Markdown
---

## Debug和Release有什么区别

- 在发布版本的构建过程中，编译器会应用他认为合适的优化。因此构建结果通常会更小，运行速度也更快
- 另一方面由于编译结果与源代码完全不匹配，所以调试难度会增加


## 什么是驱动
- 驱动程序可以使硬件设备正常工作，相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作

## 计算机三码
在计算机的数字电路中只有加法器，没有所谓的“减法器”。

计算机保存最原始的数字，是没有正负之分的，叫做“无符号数字”。

原码左边第一位存放符号，0表示正数，1表示负数。
| 优点     | 弊端     |
| -------- | -------- |
|原码直观易懂、与真值转换容易 | 0有两种表示形式 |
|  | 减法运算复杂   |




**一、为什么需要反码？** 
反码的作用就相当于数学中的负数。

对于小学生来说，会做的算术题是：5-3,但是不会做3-5。于是，我们上初中的时候，数学里就引进了一个新的概念：负数。引入负数之后，本来是减法的运算就可以变成加法来实现：
3-5=3+[-5]=[-2], 中括号代表“负数”，“负数”就是我们人为给出的数学术语。

对于计算机来说，会做的算术题是：5+3,但是不会做3-5。于是，我们就在编码里引进了一个新的概念：反码。引入反码之后，本来就是减法的运算可以变成加法来实现：
3-5=3+[-5]=[-2]，中括号代表“反码”，“反码”就是我们认为给出的计算机术语。

这里，你一定有个疑问：为什么计算机只会做5+3,但是不会做3-5。这是因为在计算机的数字电路中只有加法器，没有所谓的”减法器“。不是说计算机厂商不会设计减法器，因为聪明的人既然发明了方法能够用加法来实现减法操作，那为什么还需要画蛇添足的弄一个减法器？

接着说：那么反码要怎么定义才能实现减法变加法的功能呢？聪明的人想的办法如下：
1. 正数的反码保持原码不变：3=[0_0000011]
2. 负数除最高位（正负号位）外，全部取反（0变1,1变0）：-5 [1_0000101]取反=[1_1111010]
于是3+[-5]=[-2]的计算过程为：
[0_0000011]+[1_1111010]=[1_1111101]

**二、为什么需要补码？**
都是因为“0”这个特殊数字的存在。
先问你一个问题：0是正数还是负数？你肯定会说：0既不是正数也不是负数，这是我们初中学到的数学知识。这个回答没有问题，所以以后每次碰到0,人们都不会把他当成正数或负数。

那么计算机呢？计算机不同于人脑，**计算机在碰到任何数字之前只根据最高位的符号位来判断正负性，“0”表示正数，“1”表示负数**。







前面我们推论了为何要用反码，那么用8位二进制反码表示的正数范围：+0 —— +127；负数范围： -127 —— -0。但是，其中有两个特殊的编码会出现：
[0_0000000]=+0 （反码）
[1_1111111]=-0 （反码）

**其实，+0和-0代表的都是0。这样一来，“0”这个数字在计算机中的编码就不是唯一的了**。对于计算机来说，这是绝对不行的，因为任何数字都只能有1个编码。

于是，聪明的人就做了这样一个决定：把0当成正数，也即+0，这样0的编码就变成：0_0000000。那8位二进制表示的正数范围仍然是： +0 —— +127。

但是，对于负数就必须要做调整，也即-0必须要让位---1_1111111这个编码不能表示-0。我们可以把负数整体向后“挪动1位”：只要将8位二进制表示的负数范围从：-127 —— -0变成：-128 —— -1，就能成功解决问题。

那么怎么整体挪动1位呢？方法就是反码+1。{1_1111111}编码就不再表示-0，而变成了-1。顺着推，最小的编码{1_0000000}就是-128。







**我们给这个反码+1又人为的取了一个新的名字，叫补码**。于是乎，补码的定义如下：



1. 正数的补码保持原码不变：`3={0_0000011}`


2. 负数先求反码，然后再加1：`-5=[1_1111010]+1={1_1111011}`

于是`3+{-5}={-2}`的计算过程为：`{0_0000011} + {1_1111011}={11111110}`


至此，通过补码就成功解决了数字0在计算机中非唯一编码的问题，且也能实现减法变加法。

所以，在计算机的世界里，0是正数。这点和我们学的数学不一样。

{0_1111111}=+127 （补码）

{0_0000000}=+0 （补码）

{1_1111111}=-1 （补码）

{1_0000000}=-128 （补码）





## 位操作

#### 操作
| 按位与     | &     |都为1时 才为1 |
| -------- | -------- |--------|
| 按位或 | \| |有一个为1时 则为1|
| 按位异或 | ^ | 不同则为1|
|二进制反码或按位取反|~||



#### 用法
注意: 因为markdown语法远古
mask 0 0 0 0 0 0 1 1
flag 1 0 0 1 0 1 1 0
| 用法| 例如|解释 |结果|
| -------- | -------- |--------|--------|
| 掩码 | flags = flags & mask |把掩码中的 0 看作不透明 1看作透明|0000010|
| 打开特定位 | flags = flags \| mask | 把flags的1号位设置为1且其他位不变。**任何位与0的组合结果都为本身，任何与1组合结果都为1**。即00001111 \| 10110110|10111111|
|关闭位(清空位)|flags = flags & ~mask||00001001|




#### 位移运算符
左移运算符和右移运算符可以用于获取一些特定的位
| 左移运算符     | << n     |整体往左n 移出作末端位的值丢失 用0填充空出的位置 |相当于* 2的n次方|
| -------- | -------- |--------|--------|
| 右移运算符 | >> n |整体往右n 移出作末端位的值丢失 用0填充空出的位置|相当于/ 2的n次方|




