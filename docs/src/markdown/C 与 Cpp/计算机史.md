---
titleTemplate: Cpp Markdown
---
# 计算机史与C

## MULTICS 和 CP/M

​MULTICS 和 CP/M 虽然没有直接的前身，但它们都站在了当时计算机技术的前沿。
**​MULTICS 更多地关注大型计算机系统，而 CP/M 则面向个人计算机市场。**

​早期批处理系统: 计算机只能顺序执行作业。
​MULTICS: 多用户、多任务分时系统，对 Unix 产生了深远影响。
​Unix: **从 MULTICS 分支出来**，强调可移植性、多用户、多任务。
​CP/M: 为 8 位微型计算机设计的操作系统，**是 DOS 的前身**。
​DOS: 基于 CP/M 开发，面向个人计算机。



## 个人计算机市场
​20世纪70年代，个人计算机开始逐渐走进人们的生活。这些早期的计算机硬件资源有限，需要一个简单高效的操作系统来管理。
​命令行界面： 当时的计算机主要通过命令行的方式进行操作，用户需要输入特定的指令来完成各种任务。



### DOS（Disk Operating System，磁盘操作系统）

#### 起源

**86-DOS：**

1980年，Seattle Computer Products公司开发了86-DOS操作系统，这是DOS的雏形。86-DOS运行在Intel 8086处理器上，并提供了一些基本的磁盘管理和文件操作功能。

**微软的介入：**

微软公司看中了86-DOS的潜力，购买了其授权，并对其进行了改进和扩展，推出了MS-DOS（Microsoft Disk Operating System）。

#### 特点：

​①单用户单任务操作系统： 只能由一个用户使用，并且一次只能运行一个程序。
​②命令行界面： 用户通过输入命令与计算机交互，没有图形界面。
​③面向磁盘操作： DOS 的主要功能是管理磁盘上的文件和程序。
​④代表： MS-DOS 是最著名的 DOS 操作系统，曾广泛应用于个人计算机。
​⑤历史地位：DOS 在**个人计算机普及**初期扮演了重要的角色，**为后来的 Windows 操作系统奠定了基础。**



## Windows 1.0 的诞生

​最早的 Windows 操作系统是 1985年 发布的 Windows 1.0。

**​在 Windows 1.0 之前，个人计算机主要使用的是命令行界面，比如 DOS**。用户需要输入复杂的命令才能操作计算机。随着计算机技术的不断发展，人们对更加直观、方便的操作界面产生了需求。

**​Windows 1.0 的出现正是为了满足这种需求。 它提供了一个图形用户界面（GUI）**，用户可以通过点击鼠标和图标来操作计算机，大大降低了使用门槛。


## 大型计算机系统

#### UNIX
起源：UNIX 起源于 1969 年，由贝尔实验室的 Ken Thompson 和 Dennis Ritchie 等人开发。它最初是为多用户、分时系统设计的操作系统。


#### linux
​linux的开发始于1991年 作者是Linus目的在于创建一个自由、开源的Unix-like操作系统**内核**，以便用户能够在个人计算机上**运行类似Unix**的环境

linux本身并不是一个完整的操作系统，而是一个 操作系统内核。内核是操作系统的心脏，负责管理系统资源、进程调度等底层任务。
开源性 是 Linux 的核心特点，这使得它成为了一个非常灵活和强大的平台。



#### Ubuntu: 基于Linux的桌面操作系统
Ubuntu 是一个基于 Linux 内核的 完整的操作系统。它在 Linux 内核的基础上，添加了桌面环境、软件包管理系统、以及大量的预装软件，形成了一个可以直接使用的操作系统。
Ubuntu 以用户友好、易于安装和使用而著称，非常适合个人用户和开发者。
Debian 是 Ubuntu 的基础，它也是一个非常流行的 Linux 发行版。

#### CentOS: 基于RHEL的企业级Linux发行版
CentOS 也是一个基于 Linux 内核的完整的操作系统，但它与 Ubuntu 有所不同。
CentOS 是 Red Hat Enterprise Linux (RHEL) 的社区版，它与 RHEL 在功能上几乎完全兼容，但完全免费。
CentOS 更注重稳定性和安全性，因此非常适合用于服务器环境。

#### 三者关系总结
Linux 是一个内核，提供操作系统的底层功能。
Ubuntu 和 CentOS 都是基于 Linux 内核构建的完整的操作系统。
Ubuntu 更面向桌面用户，而 CentOS 更面向服务器用户。


## Basic语言：
1960早年代的一种教育普及语言。 Basic语言作为一种教育语言 与后来的系统编程关系不大 。

## B语言
在1960年代 贝尔实验室参与了Multics（Multiplexed Information and Computing Service）操作系统的开发。这个项目的目标是创造一个强大、复杂的多用户操作系统。

虽然Multics在功能上非常先进 但其复杂性使得开发和维护变得困难。在Multics项目中 肯·汤普逊（Ken Thompson）和其他开发者逐渐意识到 需要一个更简单、更易于实现的操作系统。

1969年 汤普逊开始开发Unix 这个新系统的设计理念是简单性和模块化。为了支持Unix的开发而设计的 提供一种更简洁的编程语言 以便快速开发和修改系统软件，B语言诞生了。

B语言的语法和结构都经过简化 适合在当时的计算机资源有限的环境下使用。由于B语言的简单性和灵活性 它成为了Unix系统早期版本的主要编程语言。在B语言的使用过程中 开发者发现B语言的功能有限 特别是在处理数据类型和复杂结构方面。


## C语言

#### 介绍

C语言的主要目标是为Unix系统提供一种更强大和灵活的编程语言 能够更有效地进行系统编程。
它引入了类型系统、结构体、指针等概念 增强了对系统资源的控制能力(手动管理内存)。

C语言**最初在1972年用于重写Unix操作系统**的核心部分 使得Unix能够更容易地移植到不同的计算机硬件上。**C 语言是与 UNIX 操作系统一起被开发出来的 但它不只支持UNIX。**
C语言是一门面向过程的计算机编程语言 与C++、C#、Java、Python等面向对象编程语言有所不同。

#### 特点

①直接操作硬件： C语言允许程序员直接操作硬件，包括内存、寄存器等，这对于需要精细控制硬件的嵌入式系统来说非常重要。
②执行效率高： C语言编译生成的代码执行效率高，占用系统资源少，这对于资源有限的嵌入式设备来说至关重要。
③接近汇编语言： C语言的语法相对简单，但又保留了部分汇编语言的特性，可以实现对硬件的精细控制。

#### 不是面向对象语言的原因：

​	C语言虽然有结构体 但它本质上并不是面向对象语言 这主要是因为它缺少面向对象编程的几个核心特性。

**①没有类和对象的概念：**

C语言的结构体虽然可以用来组织数据，但它不是真正的类。

类是面向对象编程的核心概念，它不仅包含数据 还包含操作这些数据的函数（方法）。C语言中没有“对象”这个概念 结构体只是一个数据集合。

**②不支持继承和多态：**

继承是面向对象编程中非常重要的特性 它允许一个类继承另一个类的属性和方法。C语言的结构体不支持继承。
​多态是指不同对象对同一消息做出不同响应的能力。C语言也没有直接支持多态的机制。

**③没有封装性：**

封装是将数据和操作数据的方法结合在一起形成一个独立的单元。C语言的结构体虽然可以封装数据，但不能很好地封装方法。





## GNU

GNU是一个项目，是一个开发大量免费Unix软件的集合。

为什么叫GNU呢？起名就是 GNU IS NOT Unix。**其中GNU的编译器集合，又叫GCC**。

Gcc在委员会指导下，它的C编译器紧跟C标准，有各种版本以适应不同硬件平台和操作系统。如unix linux windows



### GCC、LLVM 和 Clang 是编译器领域的三大巨头，它们之间有着密切的联系。

#### GCC（GNU Compiler Collection）
​① 历史最悠久： GCC 是一个功能强大、性能优异的编译器套件，支持多种编程语言，包括 C、C++、Objective-C、Fortran 等。
​② 开源： GCC 是一个开源项目，经过多年的发展，拥有庞大的用户社区和丰富的生态系统。
复杂性高： 由于历史悠久，GCC 的代码库非常庞大且复杂，这使得它的维护和扩展变得困难。

#### LLVM（Low Level Virtual Machine）
​① 模块化设计： LLVM 采用模块化的设计，将编译过程分为前端、优化器和后端三个阶段。这种设计使得 LLVM 具有高度的灵活性，可以支持多种编程语言和硬件平台。
​② 中间表示（IR）： LLVM 引入了中间表示（IR），这是一种类似于汇编语言的低级语言，但具有更强的表达能力。IR 使得 LLVM 可以进行更高级的优化。
​③ 可扩展性强： LLVM 的架构非常灵活，可以方便地添加新的前端和后端，支持新的编程语言和硬件平台。

#### Clang
① LLVM 前端： Clang 是 LLVM 的一个前端，主要用于编译 C、C++ 和 Objective-C 语言。
② 性能优异： Clang 的编译速度比 GCC 更快，错误提示也更加友好。
③ 模块化设计： Clang 继承了 LLVM 的模块化设计，具有高度的灵活性。

#### 三者之间的关系

① Clang + LLVM = GCC 的替代品： Clang 和 LLVM 的组合可以作为一个完整的编译器，在很多方面都优于传统的 GCC。
② LLVM 是一个基础设施： LLVM 提供了一个强大的编译器基础设施，Clang 是基于 LLVM 的一个前端。
④ GCC 兼容 LLVM： GCC 也可以使用 LLVM 作为后端，这使得 GCC 可以受益于 LLVM 的优化和扩展能力。

#### 总结

GCC 是一款成熟稳定的编译器，但其复杂性限制了它的发展。
LLVM 提供了一个灵活的编译器基础设施，具有良好的可扩展性。
Clang 是一个基于 LLVM 的高性能编译器前端，在编译速度和错误提示方面表现出色。



#### 在选择编译器时，可以根据以下因素进行考虑：

1.项目需求： 如果需要支持多种编程语言或进行复杂的优化，LLVM 是一个不错的选择。
2.编译速度： 如果对编译速度有较高要求，Clang 是一个很好的选择。
3.生态系统： GCC 拥有庞大的生态系统，而 LLVM 的生态系统也在不断发展。

**总的来说，LLVM 和 Clang 的出现为编译器领域带来了新的活力，它们正在逐渐取代 GCC 的地位。**



## MinGW

全称: Minimalist GNU for Windows

**C编译器不是windows的标准软件包的一部分，你需要从网上下载(如MinGW)，以便于在pc上使用命令来操作GCC编译器**

作用: 将 GCC 编译器移植到了 Windows 平台上，使得我们在 Windows 系统上可以使用 GCC 来编译 C/C++ 代码。
特点:
① 提供了在 Windows 上使用 GCC 的接口。
② 包含了 Win32 API，使得编译出来的程序可以在 Windows 环境下运行。

## CMake

作用: 一个跨平台的构建工具，用于生成特定平台的构建文件（如 Makefile、Visual Studio 项目文件等）。
特点:
① 编写 CMakeLists.txt 文件来描述项目结构和编译规则。
② 可以根据不同的平台和编译器生成相应的构建文件。
③ 简化了项目构建过程，提高了可移植性。

## GCC（全称: GNU Compiler Collection）

作用: 一个功能强大的编译器套件，用于将 C、C++ 等高级语言编译成机器码。
特点:
① 开源免费，支持多种编程语言。
② 编译优化能力强，生成高效的机器码。

## 三者之间的关系

CMake 生成构建文件，GCC 执行编译: CMake 通过解析 CMakeLists.txt 文件，生成适合当前平台的构建文件（如 Makefile）。然后，构建工具（如 make）会根据生成的构建文件调用 GCC 编译器来编译源代码。
Mingw 提供 GCC 在 Windows 上的运行环境: Mingw 将 GCC 移植到了 Windows 平台上，使得我们可以使用 CMake 生成针对 Mingw 的构建文件，然后使用 Mingw 提供的 GCC 编译器来编译我们的项目。

## 流程
1.Cmake读取cmakeList.txt文件，确定结构、源码文件和依赖项目
2.Cmake根据系统环境和选定的编译器(minGW) 生成对应的构建文件(MakeFile)
3.minGW通过make命令调用gcc或g++



## g++
**g++介绍**
1.C++ 编译器的代名词： 由于 g++ 在 C++ 社区中非常流行，以至于很多人将 g++ 等同于 C++ 编译器。
2.简单易用： g++ 的命令行选项相对简单，易于上手，所以被广泛使用。
3.开源免费： 作为 GCC 的一部分，g++ 也是开源免费的，这使得它成为了很多开源项目的首选编译器。

**g++ 与 GCC 的关系**
1.g++ 是 GCC 的一部分： g++ 是 GCC 中专门用于编译 C++ 代码的编译器。
2.功能重叠： 实际上，gcc 和 g++ 可以用来编译 C++ 代码。之所以有 g++，主要是为了方便用户记忆和使用。





**ISO**： ISO（_International Organization for Standardization_，国际标准化组织）

**ANSI** ： ANSI（_American National Standards Institute_，美国国家标准协会）
ANSI C也就是美国国家标准协会发布的C语言的标准，因为这个东西本来就是人家创建的，所以他说的就是标准，就是这么简单。

**C标准**
下面说的各个C语言的发布版本都是C语言的标准，只是版本的更迭

* **C89** 
1983年，美国国家标准协会（_ANSI_）成立了一个委员会 _X3J11_ ，以建立C的标准规范。

* **C90**
1990年，国际标准化组织（_ISO_）采用了ANSI C标准（格式有所更改），称为 _ISO / IEC 9899：1990_ ，也称为 _C90_ 。所以 _C89_ 和 _C90_ 几乎上是同一个标准，本来 _C89_ 是 _ANSI_ 在83创建的，然后在90年 _ISO_ 采用了这套标准。

* **C99**
进一步修订 _C_ 标准，于1999年发布 _ISO / IEC 9899：1999_ ，通常被称为 _C99_ 。引入了一些新的特性。比如内联函数，几种新的数据类型等等。

* **C11**
2011年12月8日正式发布， _C11_ 标准为 _C_ 和库添加了许多新功能，包括类型通用宏，匿名结构，改进的 _Unicode_ 支持，原子操作，多线程和边界检查功能。它还使现有 _C99_ 库的某些部分可选，并提高了与 _C ++_ 的兼容性。

C标准不仅描述c语言，还描述如何执行c域处理器，c标准库有哪些函数以及详述这些函数的工作原理。C域处理器在程序执行之前查看程序，故称之为预处理器。根据程序中的预处理器操作，预处理器把符号缩写替换成其表示的内容。预处理器可以包含程序所需的其他文件。基本上他的工作是把一些文本转换成另外一些文本。

