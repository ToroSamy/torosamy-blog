---
titleTemplate: Cpp Markdown
---
# 引用
## 引用 

通过指针，我们可以灵活地访问和修改内存中的数据

**但这也带来了严重的副作用，比如指针加加减减就可以访问相邻的内存单元**。

这会导致访问了未分配的内存、越界访问了数组、或者操作了不该操作的内存区域，就可能导致程序崩溃、数据损坏，甚至安全漏洞。

所以引用被发明了，引用就是作用阉割的指针（可以视为 `类型* const` ，所以引用必须上来就赋初值，不能设置为空），编译器不将其视作对象，操作引用相当于操作引用指向的对象。**也就从根本是杜绝了引用篡改内存的能力。**

**新手如果不懂内存，就直接将引用视为指向对象的别名就可以了。**


从底层的实现角度来看，引用在很多情况下可以被视为一个 `类型* const` 的指针，**这意味着**：

- 引用在声明时必须立即初始化，它必须指向一个已经存在的对象。这就像一个常量指针，一旦指向某个地址就不能再改变。

- 引用一旦被初始化，就不能再指向另一个对象。 这与指针不同，指针可以随时指向不同的内存地址。

- 引用不能为空（不能被设置为 nullptr）。 由于引用必须在声明时初始化，因此它总是指向一个有效的内存区域。

由于引用的这些特性，编译器不会将其视作一个独立的对象来分配内存（在大多数情况下）。

操作引用实际上相当于直接操作引用所指向的原始对象。

这就从根本上降低了通过引用意外或恶意地篡改内存的能力。

虽然在底层可能仍然涉及到地址操作，但这些操作被编译器更好地控制和约束，从而提高了代码的安全性。

**要真正理解指针，引用是需要学习c语言对应汇编的，只要懂了汇编，一目了然。不懂汇编就只能这样理解了。**

在计算机操作系统中，内存是按字节 (Byte) 进行存储和寻址的。

无论是使用指针还是引用，都不要尝试解引用（访问）未初始化的指针，因为这会导致未定义的行为，可能会引发程序崩溃或其他不可预测的问题。

虽然引用在声明时必须初始化，但在使用指针时，务必确保指针指向有效的内存地址。


## 左值
拥有地址属性的对象就叫左值，左值来源于c语言的说法，能放在“=”左面的就是左值，注意，左值也可以放在“=”右面。

## 右值
C++任何一个对象要么是左值，要么是右值。或者说无法操作地址的对象就叫做右值。

判断是否为右值，就看是不是左值，有没有地址属性，不是左值，就是右值。

比如临时对象，就都是右值，临时对象的地址属性无法使用。
```cpp
int main() {
    int i = 10;
    int i2 = i + 1;
    //(i + 1) = 200;  (i + 1)就是一个临时对象
}
```
注意：左值也可以放在 `=` 右面，但右值绝对不可以放在等号左面
```cpp
int main() {
    int i = 200;
    ++i = 200; //先++ 然后返回i的对象
    //i++ = 200; 
}
```


## 引用的分类 

### 普通左值引用
就是一个对象的别名，只能绑定左值，无法绑定常量对象。
```cpp
int main() {
    // const int i = 100;
    // int& refI = i;
    // refI = 200;
    // 如果使用了引用 const则形同虚设 所以不允许这么写
    int i = 100;
    //引用相当于别名
    int& refI = i;
}
```
### const左值引用
可以对常量起别名，可以绑定左值和右值。
```cpp
int main() {
    const int i = 100;
    const int& refI1 = i;
    const int& refI2 = 200;
}
```
### 右值引用 (*)
只能绑定右值的引用。
```cpp
int main() {
    int i = 100;
    int&& rightRefI1 = i++;
    int&& rightRefI2 = (i + 1);
    //int&& rightRefI3 = i;
}
```
### 万能引用 (*)
**下面会详细说, 这是一个很重要，但需要模板等基础的概念。**

## move函数 (*)
右值看重对象的值而不考虑地址，move函数可以对一个左值使用，使操作系统不再在意其地址属性，将其完全视作一个右值。
```cpp
int main() {
    int i = 10;
    int&& rightRefI = std::move(i);
    //std::move(i)整体右值
    //i仍然是左值 可以赋值 但不要这样做 
    //i = 20;
}
```
**move函数让操作的对象失去了地址属性，所以有义务保证以后不再使用该变量的地址属性**

**简单来说就是不再使用该变量，因为左值对象的地址是其使用时无法绕过的属性。**


## 临时对象
**右值都是不体现地址的对象。那么，还有什么能比临时对象更加没有地址属性呢？右值引用主要负责处理的就是临时对象。**
程序执行时生成的中间对象就是临时对象，注意，所有的临时对象都是右值对象，因为临时对象产生后很快就可能被销毁，使用的是它的值属性。

```cpp
int getI() {
    return 10;
}

int main() {
    int i = 10;
    //getI()返回的值就是临时对象
    int&& refI = getI();
}

```


## 万能引用
C++11除了带来了右值引用，还带来了万能引用，也就是既能当做左值，又能当做右值的引用。

万能引用是既可以被编译期处理为左值引用，又可以被编译期处理为右值引用。

**不是既是左值引用又是右值引用，不违背C++一个引用不是左值引用，就是右值引用的基本说法**

**万能引用会在编译期被当做左值引用或右值引用处理。**
### 作用
就是当参数为左值时。T&&为左值。当参数为右值时，T&& 为右值。
### 格式

#### 模板型
```cpp
#include <iostream>
#include <boost/type_index.hpp>

using boost::typeindex::type_id_with_cvr;
//这个T&& 就是万能引用类型。
//注意：只有T&& 是万能引用类型
template<typename T>
void test(T&& elem) {
    std::cout << "elem type is : " << type_id_with_cvr<decltype(elem)>().pretty_name() << std::endl;
    std::cout << "T type is : " << type_id_with_cvr<T>().pretty_name() << std::endl;
}

int main() {
    int i = 10;
    test(i);
    test(10);
    test(std::move(i));
}
```
```cpp
template<typename T>
class MyVector	{
public:
    template<typename T2>
    void push_back(T2&& elem) {
      //此时T2&& 的类型完全独立于MyVector类了
      //每调用一次push_back函数，都要推断T2的类型。
    }
};
```
以下的写法均不是万能引用
```cpp
const T&& parm;       //这就是普通的右值引用。
vector<T> && parm;    //这也是右值引用。
```
```cpp
template<typename T>
class MyVector{
public:
    void push_back(T&& elem) {
        //此时T&& 不是万能引用，因为T影响的是MyVector的类型。
    }
};
```


#### auto型
```cpp
#include <iostream>
#include <vector>
#include <boost/type_index.hpp>

using boost::typeindex::type_id_with_cvr;

int main() {
    int i = 10;
    auto&& elem = i;
    //auto&& elem = std::move(i);
    std::cout << type_id_with_cvr<decltype(elem)>().pretty_name() << std::endl;
}
```
```cpp
auto&& //就是万能引用。
const auto&& var //右值引用
```
```cpp
int main() {
    //rrefI的类型是右值引用 但他本身是一个左值
    int&& rrefI = 10;
}
```

## 引用折叠
引用折叠其实概念很简单,一个引用不是左值引用就是右值引用，当一个万能引用被认为左值引用时，类型应该是T& &&，此时类型就会折叠为T&。

简单来说，就是引用符号太多了，折叠为“&”或“&&”

## 完美转发
完美转发是什么呢？说到底，它描述的其实就是一个参数传递的过程，能够将一个传递到一个函数的参数，再通过该函数原封不动的传递给另一个函数（这里的原封不动不单是指参数的值，更包括参数的类型，参数的限定符）

光用语言描述确实描述不清楚，所以。
```cpp
template<typename T>
void func2(T&& parm);

template<typename T>
void func1(T&& parm) {
  func2(parm);
}

template<typename T>
void func2(T&& parm) {
    std::cout << type_id_with_cvr<decltype(parm)>().pretty_name() << std::endl;
}

int main() {
    int i = 10;
    func1(i);
    return 0;
}
```

我们发现以前的传递参数的方法都无法在万能引用中解决完美转发的问题。


于是C++提供了forward模板来解决完美转发的问题，forward模板可以使参数推断出它原来的类型，实现了完美转发。
```cpp
template<typename T>
void func2(T&& parm);

template<typename T>
void func1(T&& parm) {
  func2(std::forward<T>(parm));
}

template<typename T>
void func2(T&& parm) {
    std::cout << type_id_with_cvr<decltype(parm)>().pretty_name() << std::endl;
}

int main() {
    int i = 10;
    func1(i);
    return 0;
}
```

**完美转发就是一个专门配合万能引用的知识点，专门用来在使用万能引用的地方原封不动的传递参数。其实记住它是和万能引用配合使用的就掌握的差不多了，**