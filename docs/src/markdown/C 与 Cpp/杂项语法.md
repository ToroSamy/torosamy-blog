---
titleTemplate: Cpp Markdown
---
# 杂项语法



## 库目录
.h文件通常包含2种库 **静态库(.lib)**和**动态库(.dll)**
在程序**编译**时用到**静态**库(.lib) 在程序**运行**时用到**动态链接**库(.dll)

## 命名空间
C++经常需要多个团队合作来完成大型项目。多个团队就常常出现起名重复的问题，C++就提供了命名空间来解决这个问题。
比如团队A和团队B都需要定义一个叫做Test的类。那么可以这么做
```cpp
//这是ATest.h文件
#pragma once
namespace A{
    void test();
}
```
```cpp
//这是ATest.cpp文件
#include "ATest.h"
#include <iostream>
namespace A{
    void test() {
        std::cout<< "A::()"<<std::endl;
    }
}
```
```cpp
//这是BTest.h文件
#pragma once
namespace B{
    void test();
}
```
```cpp
//这是BTest.cpp文件
#include "BTest.h"
#include <iostream>
namespace B{
    void test() {
        std::cout<< "B::()"<<std::endl;
    }
}
```

```cpp
//这是main.cpp
#include <iostream>
#include "ATest.h"
#include "BTest.h"

int main() {
    A::test();
    B::test();
    return 0;
}
```

**命名空间的实现原理: C++最后都要转化为C来执行程序。在namespace A中定义的Test类，其实全名是A::Test。**

C++所有特有的库（指c没有的库）,都使用了std的命名空间。比如最常用的iostream。




## typedef

#### 特性
||#define|typedef|
|--------|--------|--------|
|创建的符号受限范围|类型和值|类型|
|解释|预处理器|编译器|

|typedef定义在|函数中|函数外|
|--------|--------|--------|
|typedef具有|局部作用域|文件作用域|

#### 语法
```c
typedef unsigned char BYTE;
BYTE x, y[10], *z;
```
#### 应用场景
- 方便tine_t、size_t等类型 在不同系统代表不同类型
- 简化书写的类型，例如
```c
//把FRPTC 声明为一个函数类型 该函数返回一个指针
//该指针指向内含5个char类型元素的数组
typedef char (*FRPTC()) [5];
```


## using关键字
using关键字设计的目的之一就是为了简化命名空间的。using关键字在命名空间方面主要有两种用法。
1. using 命名空间::变量名
这样以后使用此变量时只要使用变量名就可以了。
2. using namspce 命名空间
这样，每一个变量都会在该命名空间中寻找。
**所以，头文件中一定不能使用using关键字。会导致命名空间的污染。**



## auto
auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号。

auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。

auto关键字在推断类型时，如果没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。
```cpp
int main() {
    int i = 100;

    const int* const pi = &i;

    auto pi2 = pi;
    //auto 就是 int const *   (const int *)
}
```
**没有引用修饰 就是值传递 auto获取值的类型**

auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留

**因为在传递值时，修改这个值并不会对原有的值造成影响。而传递引用时，修改这个值会直接对原有的值造成影响。**
```cpp
int main() {
    int i = 100;

    const int* const pi = &i;

    auto& pi2 = pi;
    //全部保留
}
```
当然，我们可以在前面加上const，这样永远都有const的含义。
```cpp
int i = 100;
const auto i2 = i;
```
auto不会影响编译速度，甚至会加快编译速度。因为编译器在处理XX a = b时，当XX是传统类型时，编译期需要检查b的类型是否可以转化为XX。当XX为auto时，编译期可以按照b的类型直接给定变量a的类型，所以效率相差不大，甚至反而还有提升。

**最重要的一点，就是auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先。**

**auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题。**

自动变量：auto是储存类别说明符 cpp中的auto和c的auto完全不同 在编写c/cpp兼容程序 **最好不要用auto作为储存类别说明符(auto int lpox)** 但是可以用 自动类型推断(auto a = xxx)


## nullptr和NULL

**类型安全:**
nullptr 是C++11引入的关键字，它是一个指针类型，明确表示空指针。
NULL 是一个宏定义，通常被定义为整数0或者(void*)0。在C++中，NULL 可能会被解释为整数0，这可能导致一些类型安全问题。
**代码可读性:**

使用 ``nullptr`` 可以更清晰地表达你的意图，表明你正在使用一个空指针。
使用 ``NULL`` 时，可能会让人误以为是一个整数0，降低代码的可读性。
**函数重载:**
在函数重载时，``nullptr`` 可以更好地匹配指针类型的参数，避免歧义。
``NULL`` 可能会被解释为整数0，导致重载决策错误。

**总结:**
- 在C++中，推荐使用 ``nullptr`` 来表示空指针，因为它更安全、更具可读性，并且可以避免函数重载时的歧义。
- 尽量避免使用 ``NULL``，特别是在C++代码中。







## 数组
数组名是该数组首元素的地址 作为实际参数的数组名要求形式参数是一个与之匹配的指针

只有在这种情况下 c才会把int ar[]和int* ar解释成一样 也就是说 ar是指向int的指针
![alt text](array.jpg)


### 初始化
字符数组所有未被使用的元素都被自动初始化为'\0'
```c
//m1和m2不一样 因为m2 最后缺少空字符 \0
const char m1[40] = "helloworld";
const char m2[40] = "'H','e','l'....";

//让编译器确定初始化字符数组的大小很合理 
//如果创建一个稍后再确定的数组就必须在声明时指定大小
const char m3[] = "if you";
```
### 储存位置
- 通常字符串都作为可执行文件的一部分 储存在数据段中
- 当把程序载入内存时 也载入了程序中的字符串(储存在静态储存区)。
- 程序运行时 才会为该数组分配内存 此时将字符串拷贝到数组中。
- 此时字符串副本有2个 一个是静态内存区 一个是array中的。
### 定义数组
- `*p`允许`++p`, `p++`这样的操作。`array[]`不允许
- `*p`通常只能用于变量前,不能用于常量。
- `array[]`是地址常量
- `*p` 该变量是最初指向该字符串的首字符
- 如果打算修改字符串 就不要用指针指向字符串字面量








## 拓展数据类型
|关键字|描述|
|--------|--------|
|_Complex|复数类型|
|_Imaginary|纯虚数类型|
|_Bool|布尔类型 但实际是0和1|
||stdbool.h 是C标准函数库常用的头文件|

|宏名称|展开|
|--------|--------|
|bool|_Bool|
|true|整数常量1|
|false|整数常量0|
|__bool_true_false_are_defined|整数常量1|


## sizeof
计算机最小储存单位是位bit。一个字节8位，例如int类型占4个字节。
```c
char name[40]; //实际只能储存39个字符 留一个给/0 空字符
```
sizeof 计算一个对象或类型所占的内存字节数。而strlen是计算字符串长度。例如name是40个char类型的

sizeof 返回的size_t类型是一个无符号整型，但size_t不是一个新类型，size_t会根据不同系统替换。
```c
//typedef unsigned (int||long)
```
## 浮点数存储：

### 表示法
浮点数的存储通常遵循IEEE 754标准，这种表示法分为三部分：**符号位**、**指数位**和**尾数（或称有效位）**。

**符号位**: 占1位，表示浮点数的正负。0表示正数，1表示负数。
**指数位**: 在单精度浮点数中占8位，在双精度浮点数中占11位。指数采用偏移量（bias）表示法。在单精度中，偏移量是127；在双精度中，偏移量是1023。实际的指数值通过将存储的值减去偏移量获得。
**尾数（有效位）**: 在单精度中占23位，在双精度中占52位。浮点数采用规范化形式表示，意味着尾数前面有一个隐含的1（对正常数有效），实际存储的尾数是这个1后面的部分。比如，二进制数1.101在存储时只记录.101，并隐含前面的1。


**示例**
以单精度浮点数-6.75为例
- 符号位：1（负数）
- 转换成二进制：-6.75转为二进制为-110.11，规范化为-1.1011 × 2^2。
- 指数计算：2 + 127 = 129，129的二进制是10000001。
- 尾数：去掉隐含的1，记录为10110000000000000000000。

最终，-6.75的存储形式为：
- 符号位：1
- 指数位：10000001
- 尾数：10110000000000000000000

**总结: 浮点数的存储通过将数值分为符号、指数和尾数，能够有效表示范围广泛的实数。然而，这种表示法也可能引入精度损失和舍入误差，特别是在进行浮点运算时，因此在编程时需特别注意。**





## 高速缓存
在C语言中，高速缓存优化是编译器提高性能的一种方式。例如：
```c
int val1 = x;
//一些不使用x的代码
int val2 = x;
```
智能的编译器会注意到x的值在两次读取之间未改变，因此可能将x的值临时存储在寄存器中，以减少对主内存的访问时间。这种过程被称为缓存。

然而，如果在这两条语句之间，有其他代码修改了x的值，编译器就无法安全地进行这样的优化。因此，如果没有volatile关键字，编译器无法确定x是否会被外部因素改变，出于安全考虑，它会避免优化。

当声明中使用了volatile，编译器将假定变量的值在使用过程中可能变化，这时不会缓存值。通常，const与volatile可以同时使用，const用于表示变量不可被程序修改，但可能被外部代理修改，而volatile则表示变量可能会被外部因素改变。

这两个限定符的顺序不影响其功能，但必须在声明中同时使用。