---
titleTemplate: Linux Markdown
---
# 内存管理
内存管理的核心其实有两部分：
- 分页机制: 这部分**是理论部分**，偷懒不讲，可以百度一下。
- 内存池: 内存池等到网络编程时是个重点。


## 现代计算机的存储结构
![alt text](现代计算机的存储结构.png)
首先解释一下这张图，计算机的存储设备可以按照存储容量的从大到小，速度从慢到快，单位存储价格从低到高分为网络（可以认为存储数量无限），磁盘，磁盘缓存，物理内存（主存），高速缓存，寄存器。其中寄存器在cpu内部，其它的都在cpu外部。

其实大家可以这么理解 主要存储就三个 寄存器 物理内存 磁盘

## 寄存器
Cpu只能直接使用寄存器中的数据，任何数据都必须要传递到寄存器中才可以使用。

寄存器体积非常小，对于32位系统来说，有32bit，对于64位系统来说，有64bit。
从数量上来说，寄存器也很少，也就十几个。

## 高速缓存 (Cache)

在计算机发展的早期，内存访问速度相对较慢，成为了制约程序性能的瓶颈。为了弥补主内存与速度更快的寄存器之间的速度差异，**高速缓存 (Cache)** 的概念被引入。高速缓存的主要目的是通过临时存储数据，减少对速度较慢的主内存的访问，从而提高程序的执行效率。

### 工作原理

高速缓存的具体工作原理涉及复杂的硬件机制，例如缓存行、缓存命中/缺失、替换策略等。对于我们理解其在编程中的影响而言，只需要知道高速缓存是一个比主内存更快的小型存储区域，用于存储近期被频繁访问的数据即可。

### C 语言中的高速缓存优化

在 C 语言中，编译器会进行各种优化以提高程序性能，其中就包括利用高速缓存。考虑以下代码片段：

```c
int val1 = x;
// 一些不使用 x 的代码
int val2 = x;
```
一个智能的编译器可能会识别出在两次读取 x 的值之间，x 的值并没有被显式修改。因此，编译器可能会将 x 的值临时存储在速度更快的寄存器中，而不是每次都从主内存中读取。这个过程可以看作是一种缓存。

### `volatile` 关键字的作用

然而，如果上述两条语句之间，有其他代码可能会修改 x 的值（例如，通过另一个线程、硬件中断等），那么编译器进行的这种缓存优化可能会导致程序行为不正确。

默认情况下，编译器通常无法确定一个变量是否会被外部因素（超出当前编译单元的代码）所修改。出于安全考虑，如果没有明确的指示，编译器可能会避免对这样的变量进行激进的缓存优化。

volatile 关键字 的作用就是告诉编译器，被声明为 volatile 的变量的值可能会在使用过程中发生变化，这种变化并非由当前程序代码直接控制。当变量被声明为 volatile 时，编译器将不会对该变量进行缓存优化，每次访问该变量时都会直接从内存中读取。

### const 和 volatile 的同时使用

`const` 和 `volatile` 这两个限定符可以同时使用。`const` 用于表示变量在程序内部是不可修改的，而 `volatile` 则表示该变量的值可能被外部代理（例如硬件）所改变。一个典型的例子是内存映射的硬件寄存器：程序不应该修改它的值，但它的值可能会被硬件更新。

### 限定符的顺序

`const` 和 `volatile` 这两个限定符在声明中的顺序并不重要，`const volatile int data;` 和 `volatile const int data;` 的含义是相同的。但通常建议按照 `const volatile` 的顺序书写以保持一致性。
## 主存

一般我们说主存的概念，有两种，如开头的图片所示。

这里所说的主存，其实就是物理内存。物理内存就是我们使用的内存条。程序的主要过程都在内存上体现。

#### 磁盘缓存
提高磁盘与主存的交互速度。
#### 磁盘
磁盘是计算机长期存储的主要设备，比如文件就写在磁盘上。
#### 可移动存储介质
网络不必说，需要数据时从网络获取就可以了。

## 虚拟内存
用户在开发程序时是以进程为单位的，如果直接使用物理内存会非常困难，所以发明了虚拟内存的概念。

在32位的系统中，每个进程都会有一个4g的虚拟内存，我们直接操作4g的虚拟内存，然后cpu的MMU模块会将虚拟内存映射到物理内存上。

内存上的内容在系统关闭时会清空，只有写到磁盘上才可以长久存储


### 早期的内存分配机制
在早期的计算机中，要运行一个程序，需要把内存全部加载到物理内存。

这样的物理内存分配方式看上去很合理，但实际上在分配策略方面有很多问题。

在物理内存的分配方面，曾经有非常多的算法，但始终没有一个算法可以很好的解决物理内存的分配问题。

直到虚拟内存诞生。

### 进程的虚拟内存
每个进程都有一套虚拟内存地址，用来给自己的进程空间编号。然后这个虚拟内存，再通过CPU的MMU模块投射到物理内存上。

这就是虚拟内存的伟大之处 我们再也不需要怎么在物理内存上分配内存了 只需要投射一下就可以了


### 用户区在32位linux系统中占3g

#### 栈区
进程函数需要在栈上运行

#### 代码区
进程运行所需要的代码就存储在这个区域

#### 动态库加载区
在进程启动时加载必要的动态库

#### 静态变量区和全局变量区
实际上这个区还可以分为两部分。
- bss区：用来存储未初始化的全局变量，所以未初始化的全局变量均为0.
- 数据区：存储已经初始化的全局变量和静态变量。对于静态变量来说，未初始化只会有个未定义的初值

#### 环境变量区与命令行参数区
存储进程的环境变量与命令行参数。

#### 堆区
堆区可以认为最特殊的区域，其它区域在进程启动时就已经被划分，而堆区只有在进程需要时才会分配。

所以堆区又名**动态运行区**，是程序运行的主要区域。

堆区的大小也是不固定的，理论上，只要用户区使用的区域没有达到3g，就仍然可以申请堆区。
