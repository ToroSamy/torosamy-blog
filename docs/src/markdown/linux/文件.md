---
titleTemplate: Linux Markdown
---
# 文件存储系统

## 介绍
**linux最基础的设计理念之一就是: 一切对象皆文件。**

所有的目录, 文件, 命令, 设备等, 在linux系统看来都是文件

设备也被linux系统抽象为文件, 操作设备对应的文件就是在操作设备

这些文件被拆分为若干的基本存储单元, 存放在磁盘的不同物理地址上, 并具有特定的读写, 执行, 权限。


## 文件类型

#### 普通文件 (-)
纯粹的文本文件
#### 目录文件 (d)
directory的首字母。操作系统会用处理目录文件的方式处理这类文件, 而非直接把纯粹的文本展现出来, 以下的文件同理。

#### 软链接文件 (l)
link的首字。就相当于windows系统下的链接文件。至于实现原理这节课一会儿大家就明白了。
#### 块设备文件 (b)
block的首字母。就是存储数据的设备, 简单来说就是硬盘了
#### 字符设备文件 (c)
character的首字母, 主要有鼠标, 键盘, 显示器, 打字机等。因为这些设备是以字符的方式进行数据传输的, 所以叫做字符设备文件。
#### 管道文件类型 (p)
pipe的首字母, 管道文件这里这需要知道有这么个东西就可以了, 在`进程间通信`部分有详细解释
#### 套接字文件类型 (s)
socket的首字母, 具体有什么功能下一课再讲。

## 文件系统

常见的文件系统有`ext2`, `ext3`, `ext4` 等（**知道有这些名字就可以了, 具体的不用管**）。

在硬盘中依旧储存的是纯粹的字符 但是这些文件系统会把这些字符解析为目录

不管采取哪一种文件管理系统, 文件在磁盘上的存放机制是一样的。


## 磁盘
就是用来存储数据的硬盘, 大部分人应该都见过, 没见过也无所谓, 知道这是个用来长期存储数据的硬件就可以了。
## 分区

可以被当做独立空间使用的物理磁盘的一部分。这是一个软件的概念, 操作系统是可以设置的。

- 硬盘的分区可以被分为**主分区**和**扩展分区**两种。
- **主分区**在分区后就可以马上使用, 在windows中, 就是C盘了。
- **扩展分区**必须继续划分才可以继续使用, 继续被划分出来的就叫做**逻辑分区**。
- 在windows中, 扩展分区就可以被继续划分为D盘, E盘, F盘等。D盘, E盘, F盘等也被称为逻辑分区。





### 分区原因

**为什么要分区？直接把硬盘当做一个区不好吗？** 理论上可以不分区, 但分区有诸多好处
- 系统一般单独放一个区, 这个区由于只放系统, 产生的碎片很少, 系统也就比较稳定。
- 软件放一个区, 软件的升级, 安装或卸载会产生碎片。这样比较容易管理软件, 也比较容易整理碎片。
- 多媒体设备最好再放一个区, 这些设备对硬件都会有一些损坏, 虽然程度很低。
- 多个分区, 会比较安全, 即使一个分区损坏, 其它分区也不会受到太大的影响。


### 硬件设备的文件名
| IDE硬盘|SCSI/SATA/USB硬盘|光驱|软盘|鼠标|伪设备|
|--------|--------|--------|--------|--------|--------|
| /dev/hd[a-d] | /dev/sd[a-p] |/dev/cdrom|/dev/fd[0-1] | /dev/mouse | /dev/loop[n] |

看上去设备这么多, 实际上大家只要记住几个就可以了。
- **hd系列**: 第一个IDE设备被称为hda, 第二个IDE设备被称为hdb。hda作为硬盘也可以分区, 就可以分为hda1, hda2等。
- **伪设备系列**: 对于虚拟机来说, 很多设备都是模拟出来的, 所以伪设备自然很多。

### 分区操作
分区有很多, 我们可以用`df`命令来查看分区。

通常需要/boot分区, /home分区, /var/log, swap分区。当然, 这也没什么硬规定。

一般来说至少有两个分区, "/"分区和swap分区。对于swap分区, 当内存不够时, 可以将部分数据存放在swap分区中。

如果我们要操作linux分区, 可以使用fdisk命令。fdisk命令即使对于专业的运维来说, 仍然属于比较复杂的命令。


**总的来说, 分区操作大家有个基本概念就可以了, 这些对于运维来说才是核心。**



## 扇区

磁盘控制器（具体是什么不用管, 只要知道这是一个读取磁盘的硬件设备就可以了）每次对磁盘进行读写的最小单位, 一般为512byte。
**注意: 扇区是一个硬件级别的概念, 扇区的大小是硬件厂商设定的, 我们无法更改。**


## 块
一次读取一个扇区效率太低了 因此便有了block的概念 block是一个软件级概念。文件系统读写, 存放数据的最小单元, 可以自己设置大小, 一般只能设置1kbyte, 2kbyte, 4kbyte, 其中4k byte居多。每个block只能存放一个文件的数据, 如果文件大于block的大小, 则该文件会占据多个block。如果文件小于block的大小, 也会完全占用该block, block剩余的空间不会再被使用。

**注意: 块是一个软件级别的概念, 它是文件系统的一个概念, 所以块的大小我们是可以设置的。所以, block如果设置太大, 会导致空间浪费严重, 如果设置太小, 会导致block太多, 会影响效率。**


**block的大小一般也不需要我们自己去设置, 使用默认大小就可以了。**

**比如一个文件4kb 块也是4kb 一个扇区 512byte 那你就读取8个扇区 然后这8个是一个块 一次读取整个块**

## inode
linux系统一个非常重要的设计, 将文件的属性, 权限等和文件实际数据分开存储。

前面的磁盘, 分区, 块, 扇区是所有操作系统都有的概念, 而inode windows系统没有

inode用来记录文件的属性, 一个文件占用一个inode, 同时记录该文件数据所存储的block
##### 可以认为inode就是一个文件索引, inode具有以下属性
- 文件的权限: 读, 写, 执行
-	文件所有者, 所属组
-	ctime, atime, mtime
-	文件数据存储的位置
其实还有很多, 但那些不重要, 没必要去在意。

注意: 文件的名称不存储在inode中, 文件的名称存储在目录文件中, 也就是说文件的名称本身就是目录文件的数据, 文件的名称正是文件inode的索引。
## 读取文件的过程
- 操作系统通过文件名称找到对应的inode
- 再通过inode找到文件真正存储的block
- 然后磁盘控制器开始读取block对应的扇区
- 磁盘读取到的数据达到一个block, 就传输到内存中
- 这样以操作系统系统的角度来看, block就成为了文件系统读写文件的最小单元。




## 文件目录结构

linux的目录结构不同于windows, windows的分区一眼就能看出来, 比如C盘, D盘, E盘, 而linux只有一个目录, 分区是隐藏的。

**这其实是因为linux的目录只是分区的逻辑映射, 每个分区可以作为一个目录载入到linux的文件系统中**

**其实根目录也就是一个分区的映射。这些目录就像windows的快捷方式, 指向真正存储数据的分区。**

linux的文件系统为倒树状，根目录存放着众多目录文件的名称，我们可以根据这些目录文件的名称打开下一级目录，以此类推，我们可以打开linux系统的任何一个文件。


**很多目录如果没有对应工作场景，记起来就非常困难。但实际上常用的目录就这么几个。**


#### bin目录
binary的简写，linux一切皆文件，bin目录中存放的就是普通用户可以使用的命令。二进制的可执行指令就是命令
#### dev目录
device的简写，设备文件目录，对应硬件的文件就存储在这里
#### etc目录
配置文件目录，这个目录很常用，但是新手常常对配置文件的工作方式感到疑惑，而且并不是所有的配置文件都存放在etc目录中。
#### usr目录
unix software resource的简写，usr可以说是linux最重要的目录了，各种软件资源都要往这里放。




## io系统


#### 1.系统调用读写文件的流程
- 在实际项目中，网络部分还需要经常使用write，read函数
- 至于对普通文件的操作，还是推荐使用C++语言提供的文件操作，C语言的也可以。
- 以下是简单描述 详细见 `serial-port.md`

|	函数名|open|read|write|
| -------- | -------- | -------- |-------- |
|说明 |打开|读|写|



#### 2.lseek函数
(1)	每一个已打开的文件都有一个读写位置，在打开文件时，通常的读写位置是文件的开头。若是以附加的方式打开文件，则会指向文件的末尾。

那我们如何知道读哪里 写哪里呢 每一个文件都有一个文件指针 这个文件指针指向哪里 这个文件就读哪里写哪里 如果有O_APPEND这个文件指针则从文件末尾开始 没有就是文件开头

(2)	每一个已打开的文件都有一个读写位置, 当打开文件时通常其读写位置是指向文件开头, 若是以附加的方式打开文件(如O_APPEND), 则读写位置会指向文件尾. 当read()或write()时, 读写位置会随之增加,lseek()便是用来控制该文件的读写位置。.

(3)	下列是**典型的**使用方式，这个0表示移动位置:

|	使用方式|lseek(int fildes, 0, SEEK_SET)|lseek(int fildes, 0, SEEK_END)|lseek(int fildes, 0, SEEK_CUR)|
| -------- | -------- | -------- |-------- |
|作用 |欲将读写位置移到文件开头时|欲将读写位置移到文件尾时|想要取得目前文件位置时|


(4)	返回值：当调用成功时则返回目前的读写位置, 也就是距离文件开头多少个字节. 	若有错误则返回-1, errno 会存放错误代码

**lseek函数对于互联网用的并不多。写驱动的还是需要研究的。**

#### 3.阻塞操作和非阻塞操作
(1)	阻塞操作的定义：阻塞操作是指在执行设备操作时，若不能获得资源，则挂起进程，直到进程满足可操作的条件后再进行操作。


(2)	非阻塞操作的定义：进程在不能进行设备操作时，并不挂起，它要么放弃，要么不停的查询，直到可以进行操作。

**注意：只有对设备文件进行IO操作时才有可能发生阻塞，普通文件不是设备文件。**
**现阶段，大家只要知道有阻塞，非阻塞就可以了，阻塞，非阻塞的最典型用法在网络操作部分，到那时再讲解阻塞和非阻塞。**


## 文件的操作函数
**读普通文件进行操作的函数**
stat函数和lstat函数。其实这两个函数的作用就是获取文件的属性，使用方法非常简单。
```cpp
#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>

int main() {
  struct stat statBuf{};
  int statRet = stat("num.txt", &statBuf);
  //int statRet = lstat("num.txt", &statBuf);
  if(statBuf == -1) {
    perror("stat func error");
    return -1;
  }

  std::cout << statBuf.st_size << std::endl;
  return 0;
}
```

**对目录文件进行操作**
opendir、readdir、closedir函数。这三个函数主要作用就是遍历目录，用法也非常简单，我直接演示了。
```cpp
#include <iostream>
#include <sys/types.h>
#include <dirent.h>
#include <errno.h>
#include <string>
#include <filesystem>

void readDir(const std::string& dirName, unsigned blockNum) {
    DIR* dir = opendir(dirName.c_str());
    if (!dir) {
        perror("opendir error");
        return;
    }
    struct dirent* pDirent = nullptr;

    while ((pDirent = readdir(dir))) {
        const std::string& fileName = pDirent->d_name;
        if (fileName == "." || fileName == "..") continue;

        // Print indentation based on depth
        std::cout << std::string(blockNum, '\t') << "| " << fileName << std::endl;

        // If directory, recurse into it
        if (pDirent->d_type == DT_DIR) {
            std::filesystem::path childDir = std::filesystem::path(dirName) / fileName;
            readDir(childDir.string(), blockNum + 1);
        }
    }

    if (errno) {
        perror("readdir error");
    }
    closedir(dir);
}

int main() {
    readDir("./", 0);
    return 0;
}

```

总结：这节课的几个函数，使用频率都不是很高，远远比不上open，write，read，close。但还是有意义的，应该尽量掌握。




## 对文件描述符进行操作的函数
**操作文件描述符的函数**
dup函数和dup2函数通常配合在一起使用。可以理解为给文件描述符起别名。
```cpp
int main() {
  int fd = open("num2.txt", O_WRONLY | O_CREAT | O_APPEND,0644);
  if(fd == -1) {
    perror("open file error");
    return -1;
  }

  int oldfd = dup(STDOUT_FILENO);
  if(oldfd == -1) {
    perror("dup func error");
    return -1;
  }
  if(dup2(fd, STUOUT_FILENO) == -1) {
    perror("dup2 func error");
    return -1;
  }

  const char* str = "hello world";
  if(write(STDOUT_FILENO, str, strlen(str)) == -1) {
    perror("write func error");
    return -1;
  }

  if(dup2(oldfd, STUOUT_FILENO) == -1) {
    std::string errStr = std::string("dup2 func error, line num is : ") 
                       + std::to_string(__LINE__) + "file name is"
                       + __FILE__;
    perror(errStr.c_str());
    return -1;
  }
  if(write(STDOUT_FILENO, str, strlen(str)) == -1) {
    perror("write func error");
    return -1;
  }
  close(oldfd);
  close(fd);
  return 0;
}
```

**操作文件描述符的意义**
看了我刚才的代码，肯定很多人觉得操作文件描述符有什么用啊。其实操作文件描述符还是很有用的。很多函数在声明时已经确定了作用的文件描述符，此时操作文件描述符就很有意义了。**最典型的例子就文件重定向。如果大家linux系统编程做的比较多，就容易见到把文件描述符已经写死的情况，这时这两个函数就有用了。**

**总结一下part6：第一课的open，write，read函数用的是最多的，一定要会。第二课，第三课用的频率要少很多，尽量会。**
