---
titleTemplate: TLS
---
# TLS

## SSL

SSL（Secure Sockets Layer）是最早期的加密协议，用来保障数据在传输过程中的安全。
SSL 已被废弃，因为存在安全漏洞。但很多人习惯口头上还说“SSL证书”，其实现在都是 TLS。

### SSL 证书

TLS 协议要求身份认证, 客户端要确认自己连接的服务端不是冒充的。

为此X.509 证书（俗称 SSL 证书）应运而生, 并用于身份认证, 也就是接下来的证书验证

任何以 xxxS（Secure）结尾的协议，基本就是“xxx + TLS”，因此需要 SSL 证书


## TLS
### 简介  
TLS（Transport Layer Security，传输层安全协议）是继承自 SSL 的安全通信协议，目前已经发展到 **TLS 1.3**，这是现阶段最安全、应用最广泛的版本。  

TLS 本质上是一个独立的安全层协议，它并非专为 HTTP 设计，而是基于 **TCP** 的通用安全机制。常见应用包括：  

- **HTTPS**：`HTTP over TLS`，即 HTTP 流量通过 TLS 加密传输  
- **IMAPS / SMTPS / POP3S**：邮件协议通过 TLS 加密  
- **FTPS**：FTP 基于 TLS 的安全传输  

此外，当在 **UDP** 上使用时，TLS 的变体称为 **DTLS（Datagram TLS）**，并非直接套用 TLS。  


### 工作原理
TLS 的核心流程分为以下几个环节：  

1. **握手阶段**：客户端与服务器交换信息，协商加密算法和密钥。  
2. **证书验证**：服务器通过数字证书证明自身身份。  
3. **会话密钥交换**：后续数据通信使用对称加密（高效且安全）。  

---

## 握手阶段  

TLS 1.3 的握手主要完成算法协商与密钥交换准备。  

### 证书验证相关参数  
- **supported_versions**：TLS 协议版本  
- **cipher_suites**：对称加密套件（如 `TLS_AES_128_GCM_SHA256`, `TLS_CHACHA20_POLY1305_SHA256`）  
- **signature_algorithms**：证书与握手签名算法（如 `rsa_pss_rsae_sha256`, `ecdsa_secp256r1_sha256`）  

### 会话密钥交换相关参数  
- **supported_groups**：支持的椭圆曲线/群（如 `X25519`, `secp256r1`）  
- **key_share**：提前提供的临时公钥，减少一次往返  

### 具体流程  
1. **ClientHello（客户端发起）**  
   - 提交支持的协议版本、候选加密套件、密钥交换曲线、签名算法、公钥等  
   - 额外扩展：`server_name`(SNI)、`alpn`(HTTP/2, HTTP/3)、`psk_key_exchange_modes` 等  

2. **ServerHello（服务器响应）**  
   - 从客户端提供的候选中选择版本、套件、曲线  
   - 返回自己的临时公钥  
   - 若客户端参数不合适，可能返回 **HelloRetryRequest** 要求重试（极少见）  

---

## 证书验证

### CA
CA的全称是“证书颁发机构”（Certificate Authority），它是由受信任的第三方机构负责签发和管理数字证书，以验证网络实体（如网站、用户、设备）的身份，并保障通信安全


---


### 根CA证书
#### 介绍
操作系统厂商（Microsoft Windows、Apple、Linux 发行版）、浏览器厂商（Chrome、Firefox）会有自己的信任根计划（Root Program）

他们有自己的密钥对A, 用私钥A对自己的信息和公钥进行加密获得数字签名, 并将数字签名和公钥A放入证书, 并预先安装在浏览器或者操作系统里


#### 私钥重要性
根CA的私钥一旦泄露，全世界的信任体系就崩溃（任何人都能伪造合法证书）。
所以根CA的私钥通常保存在 HSM（硬件安全模块），离线存储、物理隔离。

平时不会直接用根私钥签发终端证书，而是只用它签发中间CA证书和每隔几年更新一次中间CA证书

当签发中间CA时，根CA可能举行线下签发仪式（有摄像、多人见证、密钥分片恢复）。
一旦签好中间CA证书，就把根私钥再锁回保险柜。


---

### 中间CA证书  
中间CA需要根CA签发**中间CA证书(Intermediate Cert)**, 以便于证明中间CA是中间CA, 因此也有自己的密钥对B。

中间CA将公钥B和自己的信息一并交给根CA, 根CA使用私钥A进行数字签名后, 将中间CA证书签发给中间CA。

---

### 网站证书

每个网站都有一对专属密钥C, 将公钥C和域名信息、有效期、证书等信息等交给中间CA。

中间CA将这些信息和公钥C进行哈希运算得到哈希值, 再用私钥B对哈希值进行加密得到中间CA的数字签名。

最后将公钥C、数字签名还有上述信息放入网站证书(Leaf Cert), 签发给网站主人

---

### 用户访问网站  

当用户在浏览器中输入 `https://example.com` 时，服务器会返回一份 **证书链**，其中通常包含：  
- 网站证书（Leaf Certificate）  
- 中间 CA 证书（Intermediate Certificate）  

客户端收到证书链后，会依次验证，形成一条“信任链（Chain of Trust）”。  

---

#### 验证网站证书 
- 网站证书上带有 **中间 CA 的签名**。  
- 客户端需要使用 **中间 CA 的公钥 B** 来验证该签名。  
- 公钥 B 就存放在“中间 CA 证书”中。  
- 因此，在验证网站证书前，客户端必须先验证中间 CA 证书的有效性。  

---

#### 验证中间 CA 证书
- 中间 CA 证书上带有 **根 CA 的签名**。  
- 客户端需要使用 **根 CA 的公钥 A** 来验证该签名。  
- 公钥 A 存放在 **根 CA 证书** 中。  

---

#### 根 CA 证书
- **根 CA 证书是自签的**，即它的签名是自己生成的。  
- 浏览器并不会尝试去验证这个签名，而是直接检查根证书是否存在于操作系统或浏览器的 **受信任列表（Root Store）**  
- 如果该根证书已预装且被信任，则整个信任链才能继续。  

---

#### 信任链的逐级验证过程  
1. **验证根 CA**：确认根证书在本机信任库中。  
2. **用根 CA 公钥 A** 验证中间 CA 证书的签名。  
3. **用中间 CA 公钥 B** 验证网站证书的签名。  
4. 在验证网站证书时：  
   - 客户端先用公钥 B 对网站证书中的数字签名进行解密，得到一个哈希值。  
   - 同时，客户端对网站证书的内容（域名、有效期、公钥等）进行同样的哈希运算。  
   - 如果这两个哈希值相同，则说明证书内容未被篡改，网站证书可信。  


## 会话密钥交换  

**目标**：产生一个共享的、一次性的“会话密钥”，用于加密后续所有应用层数据（HTTP 等），并保证 **前向安全（PFS, Perfect Forward Secrecy）**。  

---

### 核心思路：ECDHE + HKDF  

1. **（EC）DHE 共享秘密**  
   - 客户端在 `ClientHello.key_share` 中提供临时公钥 `g^a`。  
   - 服务器在 `ServerHello.key_share` 中返回临时公钥 `g^b`。  
   - 双方各自计算共享秘密 `g^(ab)`（椭圆曲线场景下为点乘，常见曲线如 `X25519`、`P-256`）。  

2. **HKDF 推导密钥层级**  
   - 基于 `HKDF-Extract/Expand` 和 **握手消息哈希（transcript hash）**，逐步派生不同阶段的密钥：  
     - **handshake secrets** → 生成 *client/server handshake traffic keys*（用于加密、验证握手后半程的消息，如 `Certificate`、`Finished`）。  
     - **master secret** → 生成 *client/server application traffic keys*（用于加密实际应用数据）。  
   - 若存在 **PSK（预共享密钥）/会话恢复**，HKDF 会将 PSK 纳入，或结合 ECDHE 成为 **PSK-DHE**，依然具备 PFS。  

---

### Finished 校验（握手完整性）  
- 双方分别发送 **Finished 消息**：  
  - 内容是对“到目前为止所有握手消息的哈希”的一个 **MAC 证明**（基于刚派生的 `finished_key`）。  
- 若双方 Finished 校验一致，证明：  
  1. 握手消息未被篡改  
  2. 双方确实拥有同一份会话密钥  

---

### 进入应用数据阶段  
- 后续 HTTP 等应用层数据使用 **AEAD 算法**（如 `AES-GCM`、`ChaCha20-Poly1305`）加密，确保 **机密性 + 完整性**。  
- 支持 **Key Update**：可轮换流量密钥，降低长期密钥泄露风险。  

---

### 前向安全（PFS）  
即使服务器的长期私钥在未来泄露，也无法解密历史通信。  
原因是每次会话密钥都由临时密钥 `a`、`b` 生成，与长期私钥无关。  

---

## 会话恢复与 0-RTT  

1. **Session Resumption（会话恢复 / PSK / Ticket）**  
   - 服务器在首次会话结束时发放一个 **Session Ticket**。  
   - 下次连接时，客户端带上 Ticket 作为 PSK，免去证书链传输和签名验证，加速握手。  
   - 推荐使用 **PSK + DHE（PSK-DHE）**：即便票据泄露，仍可保持前向安全。  

2. **0-RTT Early Data（零往返数据）**  
   - 使用 PSK 时，客户端可在服务器最终确认前直接发送少量早期数据（0-RTT）。  
   - **风险**：0-RTT 数据可被 **重放（Replay）**。  
   - 因此对涉及写操作（如下单、转账）必须禁用 0-RTT，或实现 **幂等性 / 防重放机制**。  